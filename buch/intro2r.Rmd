--- 
title: "Einführung in R"
author: "René-Marcel Kruse"
date: "`r Sys.Date()`"
site: bookdown::bookdown_site
output: bookdown::gitbook
documentclass: book
bibliography: [book.bib, packages.bib]
biblio-style: apalike
link-citations: yes
---


# Einleitung {-}

Dieses Skript ist als Teil der Bachelorveranstaltung Statistik der Wirtschaftswissenschaftlichen Fakultät der Universität Göttingen entstanden und soll Studenten helfen auf eine einfache und direkte Art und Weise die wichtigsten Funktion der Statischen Programmiersprache **R** zu verstehen und anwenden zu können. Der Inhalt soll des Weiteren allen Studierenden helfen welche Interesse oder Fragen hinsichtlich **R**-Programmierung haben.

Die aktuellste Version des Skriptes, sowie die unterliegenden Source-Files, sind im Gitlab-Repository ["intro2r"](https://gitlab.gwdg.de/kruse44/intro2r) zu finden.

Dieses Skript wurde in [Rmarkdown](https://rmarkdown.rstudio.com/) und dem [learnr](https://rstudio.github.io/learnr/)-Package geschrieben und erstellt. Es handelt sich hierbei um einen Work-in-Progress und wird ständig durch Mitarbeiter des Lehrstuhl Statistik der Universität Göttingen erweitert und verbessert. Daher würden die Autoren sich sehr über Verbesserungsvorschläge, neue Ideen oder Fehlermeldungen freuen. Hierfür einfach eine E-Mail an folgende Adresse:

  &emsp;&emsp;&emsp; gitlab+kruse44-intro2r-10509-issue-@gwdg.de 

Das folgende Lehrmaterial ist und wird immer frei sein und kann unter einer [CC-BY-SA 4.0 Lizenz](https://creativecommons.org/licenses/by-sa/4.0/deed.de) verwendet, verbreitet und modifiziert werden.  Der Hauptautor der originalen Version ist [René-Marcel Kruse](https://www.uni-goettingen.de/en/610058.html)  (<a href="https://github.com/RMKruse/">Github@RMKruse</a>, <a href="https://gitlab.gwdg.de/kruse44">gitlab.gwdg@kruse44</a>) unter Mitwirkung von:

* Jasmin Schilling

Dieses Skript bezieht sich auf verschiedene Quellen, deren inhaltliche Aufarbeitung und Darstellung der Thematik, als Grundlage und Bezugspunkt beim Erstellen dieses Skriptes dienten. Hierbei sei vor allem auf folgende Quellen verwiesen, wobei es sich bei allen Quellen um Free-and-Open-Source Lehrinhalte der jeweiligen Autoren handelt:

* [Advanced R](http://adv-r.had.co.nz/) von [Hadley Wickham](http://hadley.nz/)
* [Merely Useful: Novice R](https://merely-useful.github.io/r/index.html) von [Madeleine Bonsma-Fisher et al.]()
* [R for Data Science](#https://r4ds.had.co.nz/) von [Hadley Wickham](http://hadley.nz/) und [Garrett Grolemund](https://twitter.com/statgarrett?lang=de)
* [Hands-On Programming with R](#https://rstudio-education.github.io/hopr/) von [Garrett Grolemund](https://twitter.com/statgarrett?lang=de)
* [Fundamentals of Data Visualization](#https://serialmentor.com/dataviz/) von [Claus O. Wilke](https://github.com/clauswilke)
* [YaRrr! The Pirate’s Guide to R](#https://bookdown.org/ndphillips/YaRrr/) von [Nathaniel D. Phillips](https://ndphillips.github.io/index.html)

Des Weiteren diente als Grundlage die Vorlesungsfolien des Statistik-Master Kurses "Introduction to Statistical Programming" von [Paul Wiemann](https://www.uni-goettingen.de/de/525900.html).

<!--chapter:end:index.Rmd-->

# Interaktion mit **R** und RStudio {#intro}

Du hast jetzt also **R** und **RStudio** auf deinem Rechner installiert und willst sofort loslegen, aber vorher ist es erst einmal wichtig zu verstehen was der Unterschied zwischen **R** und **RStudio** ist und wieso du beide brauchst.

Während es sich bei **R** um eine Programmiersprache, also eine Sprache zur Interaktion mit einem Computersystem, handelt, handelt es sich bei **RStudio** um einen sogenannten IDE (integrated development environment). Ein IDE stellt Programmierern eine Sammlung der wichtigsten Werkzeuge zur Softwareentwicklung unter einer Oberfläche zur Verfügung.

Um nun mit und in **R** zu arbeiten rufst du also einfach **RStudio** auf. WICHTIG! Nicht **R** selbst aufrufen (auch wenn dieses funktioniert und einige alte hartgesottene Programmierer darauf schwören).


## Das User Interface von RStudio
<!--TODO: Verlinkung auf Anhang für veränderungen von RStudio-->
  Wenn du **RStudio** zum ersten Mal öffnest wirst du von folgendem Bild begrüßt.

<!-- ![](images/RStudio_panes_klein.png) -->

  <img src="images/rstudio_panes_klein.png" width="600" height="450" alt="RStudio">

Was du hier siehst ist **RStudio** in seiner Standard Konfiguration. Im folgenden Abschnitt wirst du die drei bzw. vier Fenster oder auch Panes genannten Interaktionsfelder von **RStudio** näher kennen lernen und verstehen wie du diese benutzen kannst. Hierbei gehen wir von links nach rechts vor.


## Die Console-Oberfläche
<!-- TODO: R definition für code chunks ändern, die ``` werden angezeigt. -->
  Das Console-Fenster findest du in der Grundausführung von **RStudio** auf der linken Seite und es dient dir als direktes Interaktionsfenster mit **R** und dadurch mit dem Computer. Jeder Code der in der Console eingegeben und durch Enter bestätigt wird, wird durchgeführt (engl. to run code).

<!-- ![](images/console1.png) -->
  <img src="images/console1.png" width="600" height="450" alt="Die Console">

  Du kannst in die **R**-Console einfache Rechenaufgaben eingeben und **R** wird dir wie eine Art Taschenrechner die Lösung der Aufgabe ausgeben.

```{r}
2 + 3
```

Die **R**-Console ist allerdings viel mehr als eine Art Taschenrechner, du  kannst hier dem Computer direkt über **R**-Code komplexe Befehle geben.

Es ist Zeit für euren ersten selbst geschriebenen Code. Hierfür befählst du dem Rechner die Worte "Hallo Welt!" widerzugeben. Dabei nutzt du den Befehl `print()`, gibst in die Klammer die Worte ein und führst den Code über das Drücken der Enter +  Strg -Tasten aus (alternativ einfach auf den blauen Button "Run Code" klicken). Hierbei ist es wichtig die Worte in Anführungszeichen einzugeben `" "` um den Rechner zu symbolisieren, dass es sich um menschliche Sprache handelt.


Herzlichen Glückwunsch! Du hast hiermit deinen ersten R-Code geschrieben.

Allerdings ist es oft schwer und sehr langwierig gewisse Befehle jedes Mal neu einzugeben, sodass **R** bereits eine Vielzahl an implementierten Befehlen wie den oben genutzten  `print()` kennt.
So kannst du ohne viel Programmierkenntnisse dem PC sagen Zahlen zu runden:

```{r}
round(2.5)
```

Oder die Uhrzeit deines Systems auszugeben:

```{r}
Sys.time()
```

Wie du mit den verschiedenen Funktionen richtig umgehst, neue hinzufügst und eigene selbst schreibst wirst, du im späteren Verlauf lernen können.

##  Die Script-Oberfläche

  <!-- TODO: Einleitung: Oft einfacher Über Skript zu gehen anstatt alles immer einzutippen -->

Das Eingeben von Code in die Console kann auf Dauer mühsam sein, vor allem wenn du denselben Code wiederholst, komplexere Eingaben tätigst oder aufeinander folgende Operationen ausführen willst. Daher kommen wir nun von der Console zur Script- oder Source-Oberfläche.

Diese Oberfläche ist beim ersten Starten von **RStudio** nicht zu sehen, kann allerdings über den Reiter File --> New File --> R Script geöffnet werden. Alternativ kannst du einfach ein neues Skript über die Tastenkombination: Strg + Shift + N öffnen. Hierbei sei die Nutzung des Keyboard-Shortcuts zu bevorzugen, da diese Art und Weise schneller und direkter von statten geht.

Du wirst nun ein leeres Dokument sehen in welchem du den R-Code schreiben kannst, ohne ihn gleich auszuführen. Diese Oberfläche bzw. das Skript selbst, dient also als eine Art Sammelstelle für deinen Code. Das Skript kann ebenfalls gespeichert werden, sodass du in der Lage bist Code später (wieder) auszuführen oder ihn gar zu teilen oder später bei einer Seminar- oder Abschlussarbeit abzugeben.

  <!-- ![](images/source.png) -->

<img src="images/source.png" width="600" height="450" alt="Source Pane">

Wenn du nun Code in dein neues Skript eingibst wirst du merken, dass dieser nicht sofort ausgeführt wird. Um den Code zu nutzen musst du diesen an die Console "schicken". Hierfür gibt es verschiedene Methoden. Dabei kannst du zum einen den auszuführenden Code mit der Maus/Keyboard markieren und dann auf den Button "Run" klicken. Der viel einfachere und von uns vorgeschlagene Weg ist, einfach den Code durch das drücken von Strg + Enter (Linux, Windows) bzw. Command + Enter (Mac) auszuführen.

  Ein von dir geschriebenes Skript kannst du einfach über den Reiter File --> Save As abspeichern, sodass du das File jeder Zeit an dem Ort findest mit dem Namen "Euer_Skript_Name.R".

##  Die Environment-Oberfläche

<!-- TODO: Verweis auf das Kapitel für Objekte etc einfügen -->
Das in der Ausgangskonfiguration sich rechts oben befindliche Environment-Feld dient verschiedener Aufgaben. In aller erster Linie sind dort alle Objekte zu finden welche gerade in R definiert sind. 

<!-- ![](images/environment_history.png) -->

<img src="images/environment_history.png" width="600" height="450" alt="History Pane">

Als kleines Beispiel der folgende Code:


```{r, eval = TRUE}
1:10
x <- 1:10
```

<!-- <!-- ![](images/environment_beispiel.png) -->

<!-- <img src="images/environment_beispiel.png" width="300" height="200" alt="Environment Pane"> -->


Hierbei erstellst du eine Sequenz an Zahlen von 1 bis 10. Im ersten Beispiel wird diese Sequenz ausgegeben, während beim zweiten Beispiel du der Variable `x` die Werte der Sequenz von 1 bis 10 zuweist. Im folgenden Kapitel werden wir im genaueren die Thematik des Variablen zuweisen behandeln, jetzt reicht es zu verstehen, dass durch diese Zuweisung eine Variable gespeichert wird, welche den jeweiligen Wert speichert. Darüber hinaus  erscheint nun rechts im Environment Feld der Eintrag für `x`. Dies bedeutet, dass nun wann immer du in der R Console oder im Skript die Größe `x` benutzt die zugewiesene Sequenz von 1 bis 10 ausgegeben oder benutzt wird.

<!-- ![](images/console_beispiel.png) -->

<img src="images/console_beispiel.png" width="600" height="450" alt="">


Wenn du auf den zweiten Tab „History“ klickst wird dir eine chronologische sortierte Auflistung aller von dir ausgeführtem **R** Befehle angezeigt. Dieser Tab hilft dir also als eine Art Anlaufstelle für Fehlersuche oder zu verstehen was du beim letzten Mal in **R** überhaupt gemacht hast.

<!-- ![](images/history_beispiel.png) -->

<img src="images/history_beispiel.png" width="600" height="450" alt="">


Zu guter Letzt bietet die Environment-Oberfläche das manuelle Einlesen von Daten über den Butto "Import Dataset". Indem du diesen Button bedienst öffnet sich ein Dropdown Menü indem du die verschiedenen Arten von importierbaren Daten auswählen kannst. Dieses Menü erlaubt dir so das einlesen und bearbeiten von Daten aus

  - Text-Datein (.txt, .csv, ...)
  - Excel (.xls, .xlsc, .xml, ...)
  - SPSS
  - STATA
  - SAS

Wie man nun genauer diese Daten einließt, wird in einem der folgenden Kapiteln genauer beschrieben.

##  Die Output-Oberfläche
Die Output Oberfläche mit den vier Tabs Files / Plots / Packages / Help zeigt dir viele hilfreiche Informationen. Wir gehen jeden Tab im Detail durch.


<!-- ![](images/outputs.png) -->

<img src="images/outputs.png" width="600" height="450" alt="">



  **Files** - Das Datei-Panel gibt dir Zugriff auf das Dateiverzeichnis auf deiner Festplatte. Eine nette Eigenschaft des "Dateien"-Panels ist, dass du es benutzen kannst, um dein Arbeitsverzeichnis festzulegen - sobald du zu einem Ordner navigierst, indem du Dateien lesen und speichern möchtest, klicke auf "Mehr" und dann auf "Als Arbeitsverzeichnis festlegen". 
 
 **Plots** - Das Plots-Panel, zeigt alle deine Plots. Es gibt Schaltflächen zum Öffnen des Plots in einem separaten Fenster und zum Exportieren des Plots.
 
**Packages** - Zeigt eine Liste aller auf deiner Festplatte installierten **R**-Pakete an und zeigt an, ob sie derzeit geladen sind oder nicht. Pakete, die in der aktuellen Sitzung geladen sind, werden geprüft, während die installierten, aber noch nicht geladenen Pakete nicht markiert sind. 

  **Help** - Hilfemenü für **R**-Funktionen. Du kannst entweder den Namen einer Funktion in das Suchfenster eingeben oder den Code verwenden, um nach einer Funktion mit dem Namen



<!-- ![](images/help_beispiel.png) -->

<img src="images/help_beispiel.png" width="600" height="450" alt="">



Hierfür gibt es neben der Eingabe in das Suchfeld verschiedene weitere Möglichkeiten Hilfe zu finden. Die erste, du nutzt ein einziges `?` gefolgt von dem Namen der Funktion zu der du mehr wissen möchtest, oder du nutzt `?? ` gefolgt von einem Ausdruck zu dem du mehr wissen möchtest. Wie du hieran erkennen kannst ist der Unterschied einfach darin zu sehen, dass man nur ein Fragezeichen nutzt, wenn man bereits die Funktion kennt, um die es geht und zwei Fragezeichen, wenn man eine Funktion finden möchte, um ein Problem zu lösen. 

```{r, eval = FALSE}
?sd
# Oder auch möglich als
help(sd)
# Möchtest du eine Funktion für Quantile finden:
??quantile
```

Falls du nicht direkt die Lösung deines Problems findest, die Erklärung/Beispiel nicht verständlich genug ist oder dein Problem zu komplex für die interne **RStudio**-Hilfe ist, gibt es verschiedene Arten um an Hilfe zu kommen.

Eine der größten, wichtigsten und oft hilfreichsten Plattformen ist <a href="https://stackoverflow.com/" title="s">StackOverflow</a>


<!--chapter:end:01-intro.Rmd-->

# Einführung in **R**-Programmierung {#kapitel3}
  
Nach dem wir im letzten Kapitel uns **R** und dessen IDE RStudio genauer angeschaut und dabei erste Beispiele für das Programmieren in **R** gesehen haben, wird es Zeit uns in diesem Kapitel genauer mit der Programmierung in **R** zu befassen.
Du wirst lernen was Objekte in **R** sind, wie man Funktionen richtig anwendet und neue Funktionen durch das installieren von Packages **R** hinzufügt. 
<!-- Des Weiteren wirst du lernen wie man Code richtig liest, was gute Konventionen beim Schreiben von Code sind und wie du einen guten Workflow in dene Arbeitsweise einarbeitet. -->


## Zuweisung und Recalling Objekts {-}
  
Im letzten Kapitel haben wir ein Beispiel gehabt, indem wir einer Variable `x` die Sequenz von 1 bis 10 zugewiesen haben. 
Durch diese Zuweisung war die Sequenz an die Variable `x` gebunden, sodass jedes Mal wenn `x` in der Console abgerufen worden ist, die Sequenz von 1 bis 10 wiedergeben worden ist. 
Generell kann man **R** wie einen Taschenrechner nutzen, allerdings können wir ebenfalls wie bei dem Sequenz Beispiel Rechnungen, Werte oder andere Dinge gewissen Ausdrücken wie der Variablen `X` zuweisen um sie so zu speichern.
Für einfache Zuweisungen, wie wir sie in diesem Kurs uns anschauen werden, nutzen wir immer den `<-` Operator. 
Also ein gewisser Wert, der rechts steht, wird einer Variablen die links steht zugewiesen. 
Du kannst auch `=` für Zuordnungen verwenden, aber nicht in jedem Kontext. 
Wegen der geringfügigen Unterschiede in der Syntax ist es sinnvoll, für Zuweisungen immer `<-` zu verwenden.
Hierbei müssen Variablen nicht unbedingt einzelne Variablen wie `x` sein, sie können auch Namen tragen. 
Als Beispiel des Zuweisens von verschieden Werten zu verschiedenen Variablen

  
```{r}
  x <- 13
  x
```

Hierbei wurde der Variablen `x` der Wert 13 zugewiesen und im nächsten Schritt wird der Variablen `x` erneut ein neuer Wert von 2 zugewiesen.
  
```{r}
  x <- 2
  x
```

Du kannst hierbei sehen, dass durch die zweite Zuweisung die erste Zuweisung aufgehoben worden ist und durch die neue ersetzt worden ist. 
Solltest du deinem Code Kommentare hinzufügen wollen, welche nicht durch **R** ausgeführt werden sollen, nutzt du zuerst das Symbol `#`. 
Wobei es einfacher ist erst deinen Kommentar zu formulieren, diesen zu markieren und durch das Drücken der Tastenkombination `Strg + Shift + c` wird dieser Part automatisch zu einem Kommentar.
  
```{r}
# Kleines Beispiel eines String-Vectors

  beispiel <- "hallo welt!"
  beispiel
```
Das dritte Beispiel zeigt dir, dass ebenfalls ganze Namen oder andere Zeichenkombinationen einen Wert zugewiesen bekommen können. 
Dir fällt ebenfalls auf, dass das dritte Beispiel keinen Zahlenwert darstellt, sondern Text einen sogenannten String. 
Zu den verschiedenen Datentypen in **R** kommen wir im nächsten Kapitel

**R** unterscheidet übrigens zwischen Groß- und Kleinschreibung bei Variablennamen. 
Wenn wir eine Variable `alleTeilnehmer` definiert hätten, könnten wir nicht mit weiter `AlleTeilnehmer` rechnen.
  
Es gibt allerdings einige Namen für Variablen welche du nicht in **R** nutzen solltest, da diese zu Problem führen (können). 
Die Namen der Objekte sollen die folgenden Zeichen nicht enthalten `^, !, $, @, +, -, /, or *`. 

Als letzte Regel soll man keine bereits bestehenden Funktionsnamen überschreiben.

<!--chapter:end:02-literature.Rmd-->

# Daten Strukturen in R

Um nun mit **R** zu arbeiten, ist es wichtig zu verstehen wie **R** überhaupt mit Daten umgeht, sie speichert und viel mehr noch wie du als Nutzer mit diesen arbeiten kannst. 
Daher schauen wir uns zu Beginn wir uns erst einmal an in welchen Formen (Strukturen) Daten in **R** gespeichert werden können.

Die Basisdatenstrukturen von **R** können nach ihrer Dimensionalität (1 x d, 2 x d oder n x d) und danach organisiert werden, ob sie homogen (alle Inhalte müssen vom gleichen Typ sein) oder heterogen (die Inhalte können von unterschiedlichem Typ sein) sind. 
Daraus ergeben sich die fünf in der Datenanalyse an den häufigsten verwendeten Datentypen:

| Dimension      | Homogen             | Heterogen     |
| -------------- |:--------------------| :-------------|
| 1 x d          | (Atomarer) Vektor   | List          |
| 2 x d          | Matrix              |   Data Frame  |
| n x d          | Array               |    -          |


Eine Besonderheit von **R** ist es, dass es keine skalaren Typen kennt. 
Einzelne Daten die wir als Menschen als Skalare wahrnehmen würden, sind trotzdem für **R** ein Vektor mit der Länge 1.

Wir starten mit dem einfachsten und wahrscheinlich wichtigsten Daten Typ in **R** den Vektoren. 
Ein Vektor besteht entweder homogen aus der gleichen elementaren oder "atomaren" Klassen (sog. Atomare Vektoren) oder aus heterogen Daten als Listen.

## Vektoren 

Um atomare Vektoren zuerstellen nutzt man den` c()`-Operator, der kurz für combine steht. 
Hierfür weisen wir einfach einer Variablen einen Vektor dadurch zu, dass wir in die Klammern des `c()`-Operators die jeweiligen homogenen atomaren Objekte aufführen die indem Vektor vorhanden sein sollen.

```{r}

x <- c(1, 2, 3)

```

Nun stellt sich allerdings erst einmal die Frage was sind diese atomaren Objekte? 
Hierfür gehen wir in diesem Skript die für uns wichtigsten vier sogenannter atomaren (also kleinst mögliche Form) Objekten in **R** durch. 
Jede der verschiedenen Formen verlangt eine andere Form der Notation. Hierbei handelt es sich um die
  
  1. Logical
  2. Integer
  3. Double
  4. Character
  
  

  
### Logicals

Bei den **Logicals** handelt es sich wie der Name schon verrät um logische Aussagen. 
Logische Werte nehmen einen von zwei möglichen Werten an `TRUE` oder `FALSE`, bzw. deren Abkürzung in Form von `T` und `F`. 

```{r logicalBSP}
logicalBSP <- c("FALSE", "TRUE", T, F)
```
  

### Doubles
  
Bei den sogenannten **Doubles** handelt es sich um Gleitkommazahlen Hierbei können die Werte in Decimal-, Scientific- und in Hexadecimalschreibweise angegeben werden. 
Es gibt außerdem noch besondere Zahlenwerte welche ebenfalls zu den Doubles gehören. 
Hierbei handelt es sich um Unendlich: `Inf` bzw. `-Inf` und um die Angabe "Not a Number" `NaN`.

```{r doublesBSP}
doublesBSP <- c(42.42, 13.37, 6.66)
```  
### Integers
 
Die **Integers** (oder auch ganzzahlige Zahlen) gehören genau wie die Doubles zu den Zahlenwerten, die Besonderheit in der Notation liegt darin, dass jedem Zahlenwert ein "L" angehängt wird (`1L`)

```{r intBSP}
integerBSP <- c(2L,6L,1L,3L,3L)
```  

### Characters
   
Die Klasse der **Characters** umfasst alle eingaben von Buchstaben/Zeichenkombinationen. B
ei der Eingabe werden diese immer mit Anführungsstrichen (" " oder ' ' ) umschlossen. Beispiel: `"Hallo Welt!"`   
```{r strBSP}
stringBSP <- c("Hallo Welt!", "Ich bin R Code!")
```  
Korrekterweise sei an dieser Stelle auf zwei weitere atomare Objektarten hingewiesen, die complex- und raw-Objekte. 
Die Klasse "complex" umfasst alle Eingaben von komplexen Zahlen, während die Klasse "raw" nur im Rahmen von binären Daten genutzt wird. 
Diese beiden Arten werden in komplexeren Zusammenhängen behandelt, welche dir wahrscheinlich nicht im Rahmen der Bachelorveranstaltungen über den Weg laufen und werden daher nicht behandelt. 
Falls du Interesse an diesem Thema hast empfehlen wir das Buch: [Advanced R von Wickham](https://adv-r.hadley.nz/)

## Listen

Der große Unterschied zwischen atomaren Vektoren und Listen ist der, dass Listen alle möglichen verschiedenen Typen von Daten beinhalten können. 
Listen werden im Gegensatz zu Vektoren mit dem Befehl `list()` erstellt.

```{r listenBSP1}

lst1 <- list(3L, "Hallo", c(13.9, 42.22223), c(T, F, TRUE))

```

Interessanterweise ist es mögliche Listen in Listen zu speichern, was es ermöglicht sogenannte rekursive Vektoren zuerstellen:

```{r list2}

listception <- list(list(list(list())))
  
``` 



### Eingabe von Vektoren

Die Eingabe von Daten per Hand kann sehr langwierig sein, vor allem wenn du zum Beispiel die Folge von 1 bis 1000 als Vektor speichern willst. 
Daher gibt es Möglichkeiten Einträge über Befehle von **R** automatisiert zuerstellen. 
Hier sind ein paar der nützlichsten Methoden, die dir das Arbeiten mit **R** erleichtern:

| Funktion                         | Beispiel                          | Ergebnis                            |
|:---------------------------------|:----------------------------------|:------------------------------------|
| `c(a, b, ...)`                   |`c(1, 5, 9)`                       |`r c(1, 5, 9)`                       |
| `a:b`                            |`1:5`                              |`r 1:5`                              |
|`seq(from, to, by, length.out)`   |`seq(from = 0, to = 6, by = 2)`    |`r seq(from = 0, to = 6, by = 2)`    |
|` rep(x, times, each, length.out)`|`rep(c(7, 8), times = 2, each = 2)`|`r rep(c(7, 8), times = 2, each = 2)`|



### Faktoren

Eine spezielle Form der Vektoren sind Faktoren, welche die Kategorien oder Klassifikationen von
Vektoren angeben, welche also Kategoriale Daten darstellen. 
Durch die Anwendung der `factor()`-Funktion auf einen Vektor mit Characters bzw. Zeichenketten (Strings), verwandelt diese einfachen die Zeichen in Faktoren um. 
Als Beispiel erschaffen wir einen Vektor mit Bezeichnung für Frau (w) und Mann (m) und verwandeln
diese in Faktoren um.

```{r faktorBSP1}

sex <- rep(c("w","m"), times = 3)
sex <- factor(sex)
sex

```

Zwei nützliche Funktionen bei der Arbeit mit Faktoren sind die Checks `class()` und `levels()`. 
Die erste Funktion fragt einen Vektor welche Art von Daten vorliegen, während die zweite Funktion die verschiedenen Ausprägungen des Faktors darstellt

```{r faktorBSP2}

class(sex)
levels(sex)

```

Faktoren sind nützlich, wenn du die möglichen Werte kennst, die eine Variable annehmen kann, auch wenn
du nicht alle Werte in einem bestimmten Datensatz weißt. 
Die Verwendung eines Faktors anstelle eines Zeichenvektors (Strings) macht es offensichtlich, wenn einige Gruppen keine Beobachtungen enthalten:

```{r faktorBSP3}

summary(sex)

```


## Matrizen und Arrays

Atomare Vektoren und Listen sind wie oben bereits erwähnt als 1 x d Objekte zu verstehen. 
Fügen wir den Objekten nun eine weitere Dimension hinzu, so betrachten wir Matrix und Arrays. 
Ähnlich zu den Listen existieren zur Erstellung von Matrizen und Arrays eigene Befehle, `matrix()` und respektive `array()`.


### Matrizen

Das besondere bei Matrizen im Gegensatz zu den 1-dimensionalen Vektoren und Listen ist, dass sie mehrere Spezifikationen benötigen um erschaffen zu werden. 
So muss bei der Nutzung von `matrix()` definiert werden, welche Werte in der Matrix zu finden sein sollen, des Weiteren wie die Dimensionen der Matrix auszusehen haben, also die Anzahl der Reihen (`nrow`) und Spalten(`ncol`). 
Hier ein kleines Beispiel:

```{r matrixBSP}

m <- matrix(c(1,2,3,4,5,6), ncol = 2, nrow = 3)
m

```

Du kannst sehen, dass zuerst ein Atomarer Vektor mithilfe des Combine-Befehls eingegeben wird, gefolgt von der Anzahl der Spalten mit 2 und der Anzahl der Reihen mit 3.

### Arrays
 
Der Vollständigkeit halber  hier ein Beispiel wie man Arrays in **R** erschafft, allerdings werden keine Arrays in der Einführungs-Vorlesung der Statistik behandelt.

Ähnlich zu der Logik hinter dem Matrix Befehl müssen mehr Eingaben getätigt werden, als nur die Datenpunkte selbst, zu sehen am folgenden Beispiel

```{r arrayBSP}

a <- array(1:12, c(2, 3, 2))
a
```

Der Array Befehl folgt folgender Struktur, man definiert zum einen die abzubildenden Datenpunkte, hier in unserem Beispiel durch die Sequenz von 1 bis 12 `1:12`, gefolgt von der Eingabe der gewünschten Dimension, in diesem Beispiel durch den Vektor `c(2,3,2)`resultierend in einem Array mit den Dimensionen 2 x 3 x 2.

### Data.Frames

Data Frames sind die zweidimensionale Version einer Liste. Sie sind sehr flexible und nützliche Datenstruktur für die Datenanalyse. 
Man kann einen Data Frame als eine Art **R** Äquivalent zur Excel-Tabelle verstehen, da sie Daten in einem ähnlichen Format speichert und darstellt.

Data Frames gruppiert Vektoren in einer zweidimensionalen Tabelle. 
Jeder Vektor wird zu einer Spalte in der Tabelle. 
Folglich kann jede Spalte eines Datenrahmens einen anderen Datentyp enthalten.

Die Erstellung eines Data Frames von Hand erfordert viel Arbeit, sodass die Eingabe einfacher über die `data.frame()` Funktion geschieht. 
Nutze einfach eine beliebige Anzahl von Vektoren, die jeweils durch ein Komma getrennt werden. Jeder Vektor sollte einem Namen entsprechen, der den Vektor beschreibt.
Wichtig, jeder Vektor muss hierbei die gleiche Länge haben.
Die `data.frame()`-Funktion macht jeden Vektor zu einer Spalte des neuen Data Frames:

```{r datafBSP}

df <- data.frame(lat = c("51.5454", "53.1438", "35.7034"),
                 lon = c("9.9055", "8.2138", "139.7532"), 
                 value = c("Göttingen", "Oldenburg", "Tokyo"))
df

```



### Names

Es macht oft Sinn nicht nur den Objekten, sondern auch Variablen in **R**-Objekten Namen zu geben. 
Ein Beispiel: 

```{r namesBSP1}
alter <- c(13, 42, 39)
names(alter)

names(alter) <- c("Chris", "Henny", "Paul")
alter
```

Wir haben hier also einen Vektor der verschiedenen Altersangabe beinhält. 
Wir können nun jedem Eintrag einen Namen mit der `name()`-Funktion zuweisen, in diesem Fall drei verschiedene Namen. 
Nun wenn der Vektor abgerufen wird, werden die Namen mit den dazugehörigen Alterszahlen angegeben.
Listen und Matrizen können genauso wie atomare Vektoren Namen aufweisen. 
Bei Listen ist dies sehr hilfreich, da es so einfacher ist auf bestimmte Elemente in den Listen zuzugreifen.

```{r namesBSP2}
alter <- list("Chris" = 13, Henny = 42, Paul = 39)
alter
```

Wie man hier sehen kann, enthält die Liste nun drei verschiedene Objekte mit jeweils einem anderen Namen.
Interessanterweise kann man den Namen mit aber auch ohne Anführungszeichen eingeben, dies liegt daran,
dass wenn der Name aus mehreren Worten besteht der Name von `" "` umschlossen sein muss dies aber bei einem einzigen Wort optional ist.
Des Weiteren sind die Namen hilfreich auf einzelne Elemente der Liste zuzugreifen.

```{r namesBSP3}
alter$Chris
```

Aber zu diesem bestimmten auswählen von Teildaten und Subsets mehr im späteren Abschnitt zur Daten Manipulation.
Namen bei Matrizen haben auf Grund ihrer anderen Dimensionalität eine andere Struktur. 
Matrizen haben immer Column (Spalten) und Row (Reihen) spezifische Namen. 
Diese Namen kann man nur über die Nutzung der Funktionen `colnames()` und `rownames()` festlegen und verändern oder indem man über den Befehl `dimnames()` gleich beide zusammen definiert.

```{r namesBSP4}

m <- matrix(1:4, nrow = 2, ncol = 2)
dimnames(m) <- list(c("a", "b"), c("c", "d"))
m

colnames(m) <- c("h", "f")
rownames(m) <- c("x", "z")
m
```

<!--chapter:end:03-method.Rmd-->

# Grundlegende **R**-Funktionen {#kapitel3.3}
  
 
**R** kommt von Haus aus mit verschiedenen bereits implementierten Funktionen wie die bereits vorgestellten `mean()`, `round()`, `print()` und vielen mehr. 
Im folgenden Abschnitt werden wir durch ein paar der wichtigsten in **R** implementierten Funktionen durchgehen um dir ein Gefühl dafür zu geben wie du mit **R**-Funktionen umgehen musst und wie du effektiv mit **R** arbeiten kannst.
  
  
## Mathematische Operationen

Bisher weißt du, wie man grundlegende arithmetische Operationen wie `+` (Addition), `-` (Subtraktion) und `*` (Multiplikation) auf Skalaren ausführst. 
Glücklicherweise macht es **R** genauso einfach, arithmetische Operationen auf numerischen Vektoren durchzuführen:


```{r arithBSP}

x <- c(1, 2, 3, 4, 5)
y <- c(5, 6, 7, 8, 9)

```

Wenn du eine Operation mit einem Vektor und einem Skalar durchführst, wendet **R** den Skalar auf jedes einzelne Element des Vektors an.

```{r vekaddBSP}
# Addition mit Skalaren
x + 100

1:5 + 10
```

Wenn du eine Operation auf zwei Vektoren der gleichen Länge anwenden willst funktioniert es recht einfach. 
**R** wendet die Operation auf beide Vektoren Element für Element an. 
Als Beispiel was damit gemeint ist:
  
```{r vektormath}
x + y
y - x
(x + y) / 10

```
## Deskriptive Statistik

Die folgenden Befehle stellen eine Zusammenfassung der für dich im Laufe des Studiums wichtigsten beschreibenden Größen der Statistik.

| Funktion                 | Beispiel                   | Output                                                                             |
|:-------------------------|:---------------------------|:-----------------------------------------------------------------------------------|
| `sum(x), product(x)`     |`sum(1:10)`                 |`r sum(1:10)`                                                                       |
| `min(x), max(x)`         |`min(1:10)`                 |`r min(1:10)`                                                                       |
| `mean(x), median(x)`     |`mean(1:10)`                | `r mean(1:10)`                                                                     |
| `sd(x), var(x), range(x)`|`sd(1:10)`                  | `r sd(1:10)`                                                                       |
| `quantile(x, probs)`     |`quantile(1:10, probs = .2)`|`r quantile(1:10, probs = .2)`                                                      |
| `summary(x)`             |`summary(1:10)`             |`Min = 1.00. 1st Qu. = 3.25, Median = 5.50, Mean = 5.50, 3rd Qu. = 7.75, Max = 10.0`|




##  Missing Values

Ein Problem, welches auftreten kann, wenn man mit echten Daten arbeitet ist, dass entweder falsche oder gar fehlende Werte auftreten. 
Sollte in deinen Daten fehlende Werte auftreten, kommen leider vielen grundlegende Statistiken zu nicht verlässlichen Ergebnissen. 
Der folgende Code gibt beispielsweise NA als Ergebnis zurück, weil ein NA-Wert im Datenvektor vorhanden ist:

```{r}
a <- c(0, 1, NA, 3, 4)
mean(a)
```

Glücklicherweise bietet **R** allerdings eine Möglichkeit, um mit `NAs` in den Daten umzugehen. 
So kann man entweder bei der Anwendung einer Funktion auf die Daten ein weiteres Argument an die Funktion weitergeben, welche dieser befiehlt, alle `NAs` in den Daten zu ignorieren. 
Bei diesem Argument handelt es sich um den Ausdruck `na.rm`, so bald dieses gleich `TRUE` gesetzt wird, ignoriert **R** alle `NAs`. 
Hier ein Beispiel:

```{r}

mean(a, na.rm = TRUE)

```

Oder es gibt die Möglichkeit alle `NAs` in den Daten zu löschen. 
Hierfür erstellt man einfach ein neues **R**-Objekt, wobei man die **R**-Funktion `na.omit()` auf die Daten anwendet. 
Als Beispiel:

```{r}
b <- na.omit(a)
mean(b)
``` 


  
## Packages

Sollte die in der base-**R** Version enthaltenen Funktionen nicht für deine Arbeit ausreichen, gibt es zwei Möglichkeiten wie du mit diesem Problem umgehst:

  1. Finden eines **R**-Packages welches Funktionen beinhält welche es erlaubt dein Problem zu lösen
  2. Eigene Funktionen zu schreiben

Ein Package ist eine Sammlung von Code, welches von einer anderen Person oder Gruppe geschrieben worden ist. Meistens sind Pakete dazu gedacht, ein bestimmtes Problem zu lösen, also Funktionen zusammenzufassen, die mit einem bestimmten datenwissenschaftlichen Problem zusammenhängen (z.B. Data Wrangling, Visualisierung, Inferenz). Jeder kann ein Paket schreiben, und man kann Pakete von vielen verschiedenen Orten bekommen.
  
  
### Wie installiere ich Package?

Die Installation eines Pakets bedeutet einfach das Herunterladen des Packages auf deinen Computer. Es gibt verschiedene Wege, neue Pakete zu installieren. Der einfachste und gebräuchlichste Weg ist das Herunterladen aus dem Comprehensive **R** Archive Network (CRAN). CRAN ist der zentrale Speicherort für **R**-Pakete. Um ein neues **R**-Paket von CRAN zu installieren, kannst du einfach den Befehl `install.packages("name")` ausführen, wobei "name" der Name des Pakets ist.
  
```{r packages, eval = FALSE}
install.packages("name")
```
Einige Pakete sind Bündel von Packages. Zum Beispiel das "tidyverse"-Package, welches viele einzelne Pakete für Daten Wrangling und Visualisierung zusammenfasst, so dass du bei der Installation von einem einzelnen Package des tidyverse eigentlich acht verschiedene Packages installierst.
  
```{r installationtidyverse, eval = FALSE}
# Installation des Package Bundles tidyverse
  install.packages("tidyverse")
  
```
  
### Wie nutze ich Packages?

Jetzt weißt du wie man Packages installiert, aber wie nutzt du diese? Um Packages zu nutzen welche nicht Teil der Base-R Version sind, müssen diese erst in die aktive **R** Session geladen werden. Hierfür nutzt du einfach den Befehl `library("name")`. Nehmen wir das Beispiel des Packages `ggplot2` welches Teil des tidyverse ist. Dazu nutzt du einfach den folgenden Code:
    
```{r, }
# Laden des Packages ggplot2
  library(ggplot2)
```
Und schon bist du in der Lage die im Package beinhalteten Funktionen zu nutzen um z.B. `ggplot2` um  ansprechendere graphische Analysen anzufertigen:
    
```{r ggplotBSP}
  
  gg <- ggplot(midwest, aes(x=area, y=poptotal)) + 
    geom_point(aes(col=state), size=3) +
    geom_smooth(method="lm", col="firebrick", size=2) + 
    coord_cartesian(xlim=c(0, 0.1), ylim=c(0, 1000000)) + 
    labs(title="Fläche Vs Population", 
         subtitle="US-Midwest dataset", 
         y="Population", x="Fläche", 
         caption="Midwest Demographics")
  
# Achsenbeschriftung ändern
  gg + scale_x_continuous(breaks=seq(0, 0.1, 0.01), 
                          labels = sprintf("%1.2f%%", 
                                           seq(0, 0.1, 0.01))) + 
    scale_y_continuous(breaks=seq(0, 1000000, 200000), 
                       labels = function(x){paste0(x/1000, 'K')})
  
```


<!--chapter:end:04-application.Rmd-->

# Funktionen und Kontroll-Strukturen

Bei einigen Aufgaben müssen sich Teile einer Berechnung wiederholen oder sie sind abhängig von bestimmten externen Bedingungen. 
Selbst denselben Befehl immer wieder abzutippen ist im besten Fall langweilig, und im schlimmsten Fall sehr aufwendig. 
Deswegen erlaubt es **R**, wie viele andere Programmiersprachen auch, repetitive Aufgaben zu automatisieren.

## For-Loops


Wenn du Rechnungen mehrfach wiederholen musst eignet sich dafür der `for()`-Befehl, der die folgende
allgemeine Form besitzt:

```{r forBSP1, eval=FALSE}
for (variable in vector) {
  # Aufgabe
}
```

Die `variable` ist eine sogenannte Zählvariable, sie zählt wie viele Durchgänge der For-loop bereits hinter sich hat.
Der `vector` ist die Spannweite von der die Zählvariable zählt, bis der For-Loop abgeschlossen ist.
Dies erscheint vielleicht relativ abstrakt, aber das folgende Beispiel sollte verdeutlichen wie ein For-Loop funktioniert.

So möchtest du zum Beispiel die Zahlen von 1 bis 25 in der **R** Console ausgeben, wird diese Aufgabe mithilfe des For-Loops sehr einfach.
Dafür musst du einfach nur den folgenden Code tippen:

```{r forBSP2}
for(i in 1:5){
  print(i)
}
```

Die Variable `i` nimmt je nach Durchlauf des Loops einen Zahlenwert von 1 bis 25 an. In jedem Durchlauf wird der jeweilige Wert von `i` ausgegeben. Dieser Vorgang startet bei 1 und endet mit dem 25ten Durchlauf.


## If-Else

Du wirst beim Schreiben von eigenen Funktionen in die Situation kommen, in der eine Funktion bedingt auf ein Ereignis reagieren muss. Diese bedingten Abfragen sehen in **R** so aus

```{r ifBSP1, eval=FALSE}
# Einfacher Fall
  if (condition) {
# expr
}

# Entweder Oder Fall
if (condition) {
  # expr
} else {
  # expr
}
```

Der Ablauf hierbei ist immer gleich, wird eine bestimmte Bedingung (condition) erfüllt, wird ein bestimmter **R** Befehl ausgeführt (expr). 
Man kann diese If-Abfrage durch eine Else-Condition erweitern, welche bei nicht Erfüllung der Bedingung einen anderen Befehl ausführen.

```{r ifBSP2}
x <- c(6)

if (x == 6) { # Wenn x = 6, dann
  print("x gleich 6")
}

if (x == 5) { # Wenn x = 5, dann
  print("x gleich 5")
} else { # Wenn x nicht gleich 5 dann
  print("x ist ungleich 5")
}
```

## While-Loops


Die while-Schleife dient dazu, eine Abfolge von Anweisungen mehrfach auszuführen, solange eine bestimmte Bedingung erfüllt ist.

```{r whileBSP1, eval=FALSE}
while (condition) {
  # Expr
}
```

Ein Beispiel für diese Form der wiederholten Ausführung eines Befehls ist hier zu sehen. So lange der Wert der Variable `i` kleiner als 6 ist, wird der jeweilige Wert von `i` ausgegeben.

```{r whileBSP2}
i <- 1
while (i < 6) {
  print(i)
  i = i+1
}
```


## Eigene Funktionen


Wenn du merkst, dass du einige Aufgaben immer wieder durchführen musst oder dass keine Funktionen existieren, welche eine bestimmte Aufgabe lösen können, solltest du überlegen eigene Funktionen zu schreiben.
Funktionen werden mit der `function()`-Anweisung definiert und wie alles andere in **R** als Objekte gespeichert. 
Ein Beispiel einer "leeren" Funktion

```{r}
f <- function() {
  ## Eine leere Funktion
  }

```

Als nächstes können wir eine Funktion erstellen, die tatsächlich einen nicht-trivialen Funktionskörper hat.
Das bedeutet, dass die Funktion auch eine wirkliche Aufgabe hat und etwas für dich ausführt. 
In unserem Beispiel ist es die Aufgabe der Funktion bei jedem Aufrufen der Funktion die Worte „Hello World!“ auszugeben.


```{r}

f <- function() {
  cat("Hello, world!\n")
}
f()

```
Der letzte Aspekt einer Grundfunktion sind die Funktionsargumente. 
Dies sind die Optionen, die der Benutzer angeben kann auf deren Basis bestimmte Aktionen durchgeführt werden. 
Für unsere Grundfunktion können wir ein Argument hinzufügen, das bestimmt wie oft "Hallo, Welt!" in der Konsole ausgegeben wird.

```{r}

f <- function(num) {
       for(i in seq_len(num)) {
               cat("Hello, world!\n")
       }
}

f(2)

```

Zu guter Letzt lernst du noch den Befehl `return()`kennen. 
Dieser Befehl sagt deiner **R**-Funktion, dass wenn die Funktion durchgeführt wird, es möglich ist einer Variablen mit HIlfe der Funktion einen Wert zu zuweisen. 
Als Beispiel schreiben wir eine Funktion welche zwei Elemente als Input nimmt und diese mit einander addiert. 

```{r, eval = FALSE}

addtwo <- function(x, y){
  z <- x + y
}

```

Führen wir nun diese Funktion aus, so werden `x` und `y` mit einander addiert und wiedergegeben. Nun willst du aber zum Beispiel diesen Wert in einem Objekt Speichern, nennen wir es einfach `v`, hierfür nutzt man einfach die folgende Funktionsstruktur.


```{r, eval = FALSE}

addtwo <- function(x, y){
  z <- x + y
  return(z)
}

v <- addtwo()

```

Gebe einfach beliebige Zahlen für die beiden Inputs ein. Du wirst sehen, dass kein Ergebnis widergegeben wird, allerdings wenn du `v` eingibst und über `Strg + Enter` abrufst das Ergebnis ausgegeben wird.



<!--chapter:end:05-summary.Rmd-->

#  Daten

In diesem Kapitel wirst du lernen wie man externe Daten in **R** einließt, wie man mit diesen Daten arbeitet, sie verändert, anpasst und exportiert.

  
## Einlesen von Daten 

Daten können aus verschiedenen externen Quellen und Dateiformaten in **R** eingelesen werden. 
Es gibt ein paar Hauptfunktionen, die Daten in **R** einlesen.

  * `read.table()`, `read.csv()`, zum Einlesen von Tabellendaten
  * `source()`, zum Einlesen von **R**-Code-Dateien
  * `dget()`, zum Einlesen von **R**-Code-Dateien
  * `load()`, zum Lesen in gespeicherten Arbeitsbereichen
  * `unserialize()`, zum Lesen einzelner R-Objekte in binärer Form

Hierbei sei darauf hingewiesen, dass es noch viele weitere **R** Packages gibt, welche es dir erlauben Daten in **R** einzulesen.
Parallel zu den verschiedenen Funktionen zum Einlesen von Daten in **R** gibt es Funktionen welche es dir erlauben Daten zu schreiben/exportieren.
    
  * `write.table()`, `write.csv()` zum Schreiben von Tabellendaten in Textdateien (z.B. CSV) 
  * `writeLines()`, zum zeilenweisen Schreiben von Zeichendaten in eine Datei
  * `dump()`, zum Ausgeben einer textlichen Darstellung mehrerer **R**-Objekte
  * `dput()`, zur Ausgabe einer textlichen Darstellung eines **R**-Objektes
  * `save()`, zum Speichern einer beliebigen Anzahl von **R**-Objekten im Binärformat (möglicherweise komprimiert) in eine Datei.
  * `serialize()`, zum Konvertieren eines **R**-Objektes in ein Binärformat zur Ausgabe.
    
    
## Das readr-Package

Ein explizit für das Einlesen erschaffenes **R** Package ist das reader-Package welches zum Einlesen von großen Datenfiles gedacht ist. 
Das Package ersetzt die im vorigen Kapitel beschriebenen Funktionen
`read.table()` und `read.csv()` mit den Funktionen `read_table()` bzw. `read_csv()`.

Generell gibts es ein paar Gründe wieso du lieber auf die Funktionen des `readr`-Packages zurückgreifen solltest als die Basis-**R** Funktionen zu nutzen.

  * Durch den effizienteren Code hinter den Funktonen ist das Einlesen von Daten um ein Vielfaches schneller, was sich vor allem bei größeren Datenfiles bemerkbar macht.
  * Die `readr`-Funktionen sind generell auch reproduzierbar. Während die Base-**R** Funktionen Eigenheiten des jeweiligen Betriebssystems des Computers übernehmen, sind `readr`-Funktionen System-agnostisch.

## Speichern von Daten

Wie bereits zu Beginn des Kapitels dargestellt, existieren analog zu den Funktionen welche Daten in **R** einlesen Funktionen, welche Daten exportieren bzw. abspeichern. Wie jede Funktion in **R** die wir bisher begegnet sind, haben auch diese Argumente die bestimmten Einfluss auf Art und Weise wie die Funktion durchgeführt wird. 

Um nun eine Liste `x` beispielhaft als CSV-Datei abzuspeichern musst du folgendes machen:

```{r savecsvBSP, eval = FALSE}

write.csv(x, file = "beispiel.csv", row.names = FALSE)

```

Der Aufbau der Argumente hat folgende Struktur. Zunächst solltest du `write.csv()` den Namen des **R**-Objektes geben, das du gespeichert haben möchtest. 
Als nächstes solltest du einen Dateinamen für deine Datei angeben. **R** wird diesen Namen ziemlich wörtlich nehmen, also stell sicher, dass du eine Erweiterung an den Namen anhängst (.csv).
**R** wandelt deine Liste dann in eine Klartextdatei in eine CSV-Datei um, in welcher Werte durch Komma getrennt sind und speichert die Datei in deinem Arbeitsverzeichnis. 

<!----------------------------------------------------------  Kapitel 7 ---------------------------------------------------------->



    
## Daten Selektion 

Es ist oft wichtig für bestimmte Operationen nur einen Teil der Daten, also ein Subset, zu betrachten und zu bearbeiten. 
Diese sogenannte Subsettig von **R** Objekten kann in Base-**R** mithilfe von drei verschiedenen Operatoren gemacht werden. 
Diese drei Operatoren sind `[]`, `[[]]` und `$`.
Der `[]` Operator selektiert ein Teil der Daten und gibt das Subset in derselben Objekt Klasse aus wie das Originale. 
Der `[[]]` hingegen kann nur einzelne Element aus Listen oder Dataframes subsetten und das resultierende Objekt ist nicht unbedingt aus derselben Objekt Klasse wie das übergeordnete. 
Schlussendlich der `$` Operator kann genutzt werden um Elemente durch Nutzung ihres Names auszulesen.
Zuerst betrachten wir wie man Subsetting mit einem Vektor macht.
  
### Subsetting von Vektoren

Zu Beginn die Anwendung des `[` Operators auf Vektoren. 
Hierbei kann man sehen, dass entweder einzelne Elemente ausgelesen werden können, ganze Folgen oder bestimmte beliebige Positionen

```{r subsetvektor1}
foo <- c("rot", "gruen", "blau", "blau", "gelb", "rot")

# Nur das erste Element des Vektors
foo[1]

# Die ersten vier Elemente
foo[1:4]

# Der erste, dritte und letzte Eintrag
foo[c(1, 3, length(foo))]

```

Oft sehr interessant ist auch die logische Abfrage von Inhalten:

```{r subsetvektor2}
  
# Alle nicht roten Elemente
foo[foo != "rot"]

```


### Subsetting von Matrizen

Das Subsetten einer Matrix erfolgt nach denselben Regel wie das Subsetten der Vektoren, wobei hier die abzufragenden
Positionen anstatt mit einer Angabe auf Grund der zwei-Dimensionalität durch zwei Angaben
zu tätigenn ist. Hier ein Beispiel anhand der im Kapitel 3 erschaffenen Matrix was damit genau gemeint ist

```{r subsetmatrix1}
m <- matrix(c(1,2,3,4,5,6), ncol = 2, nrow = 3, byrow = TRUE)
m

# Abfrage des Elements in der zweiten Reihe und der ersten Spalte
m[2,1]

```

Wenn man nun allerdings anstatt eines Elementes, alle Elemente einer Reihe oder Spalte abfragen will kann
man die jeweilige Row bzw. Column Angabe frei lassen. Beispiel hier:

```{r subsetmatrix2}
# Alle Elemente der ersten Reihe
m[1, ]

# Alle Elemente der ersten Spalte
m[ , 1]

```


### Subsetting von Listen

Listen können in **R** in drei verschiedenen Arten gesubsettet werden. Hierfür nutzt man die oben genannten drei verschiedenen Operatoren. Um die drei verschiedenen Arten zu illustrieren erschaffen wir zuerst eine Beispielsliste

```{r subsetliste1}
x <- list(foo = 1:3, faa = "hallo", faz = 0.3)

```

Eine der einfachsten und bequemsten Arten Listen zu subsetten ist die Benutzung des `$` Operators. Der Grund hierfür ist, dass wenn du den Namen der Zielliste eingibst, gefolgt vom Operator, kannst du durch das Betätigen der Tabulator Taste Rstudios Autovervollständigung nutzen. Dabei werden alle Elemente einer Liste aufgeführt und du kannst einfach das gewünschte Element über die Pfeiltasten auswählen.

```{r subsetliste2}

x$foo

x$faa

```

Ähnlich zum Subsetten der Matrizen und Vektoren, können Listen ebenso mit dem `[]`- bzw. `[[]]`-Operator gesubsettet werden. Wenn du also das erste Element der Liste auswählen willst kannst du einfach wie in folgendem Beispiel machen 

```{r subsetliste3}
x[[1]]

```

Ebenso ist es wieder möglich in Kombination mit dem `[[]]`-Operator mit Hilfe der Namen der Elemente die Liste zu subsetten.

```{r subsetliste4}
x[["foo"]]

```

Schlussendlich ist es ebenso möglich mehrere Elemente der Liste auszuwählen. Hierfür nutze einfach den `[]` oder `[[]]`-Operator und setze gebe einen Vektor an, welche die Elemente bestimmt. Allerdings sei hierbei darauf hingewiesen, dass je nach dem welchen der beiden Operatoren du nutzt verschieden Elemente ausgewählten werden .Zum einfacheren Verständnis das folgende Beispiel:

```{r subsetliste5}

# Das Zweite und das dritte Element der Liste
x[c(2,3)]

# Der dritte Eintrag des ersten Elements 
x[[c(1,3)]]
```

```{r subsetliste6}


```

<!--chapter:end:06-references.Rmd-->

# Plotten

Oft ist es wichtig Zusammenhänge nicht nur in Zahlen, sondern ebenso graphisch darzustellen. 
Das folgende Kapitel zeigt dir wie man verschiedene Arten von wichtigen grundlegenden Plots in **R** erstellt und wie man diese in einer Art und Weise kreiert, sodass man sie ohne Probleme in Seminar- oder Abschlussarbeiten nutzen kann.

Dieses Kapitel wird sich nur mit den in der base-**R** Version enthaltenen Plot-Funktionen befassen. 
Wir lassen bewusst **R**-Packages wie `ggplot2` oder `plotly` aus, solltest du dich allerdings für die Funktionalität dieser Packages und der damit verbundenen Verbesserung der Möglichkeiten der graphischen Darstellung interessieren, empfehlen wir dir die https://socviz.co/ und https://rkabacoff.github.io/datavis/ . 

  

## Plot-Funktion
  
Die einfachste Möglichkeit einen Plot in **R** zuerstellen ist die **R**-base Funktion `plot()` zu nutzen. In der Standard Einstellung erstellt der Befehl ein Streudiagramm basierend auf den beiden Input Vektoren für die Abszissen- sowie der Ordinatenwerte.  
  
```{r einfachplot}  
  
plot(x = 1:5,
     y = 1:5)

```

Erklärung der wichtigsten Argumente der `plot()`-Funktion

| Argument             | Beschreibung                                                                                                                                                                      | 
|:---------------------|:----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|`x, y`                |Vektoren gleicher Länge, die die x- und y-Werte der Punkte angeben                                                                                                                 |
|`type`                | Art der Handlung. `"l"` bedeutet Linien, `"p"` bedeutet Punkte, `"b"` bedeutet Linien und Punkte, `"n"` bedeutet kein Plotten                                                     |
|`main`, `xlab`, `ylab`| Strings, die den Titel der Handlung beschriften, und x- und y-Achsen                                                                                                              |
|`xlim`, `ylim`        | Grenzen zu den Achsen. Zum Beispiel setzt `xlim = c(0, 100)` das Minimum und das Maximum der x-Achse auf 0 und 100.                                                               |
|`pch`                 | Eine ganze Zahl, die den Typ der Zeichensymbole angibt oder eine Zeichenkette.                                                                                                    |
|`col`                 | Hauptfarbe der Plottsymbole. Zum Beispiel wird `col = "rot"` rote Symbole erzeugen.                                                                                               |
|`cex`                 | Ein numerischer Vektor, der die Größe der Symbole angibt (von 0 bis Inf). Die Standardgröße ist 1. `cex = 4` macht die Punkte sehr groß, während `cex = .5` sie sehr klein macht. |


```{r}

plot(x = 1:5,
     y = 1:5,                        
     type = "b",                      
     main = "Etwas hübscherer Plot",
     xlab = "x-Achse",
     ylab = "y-Achse ",                
     col = "red",                     
     pch = 16,                        
     cex = 1)                         

```

Generell gilt es hier, wie bei allen anderen Funktionen in **R**, wenn du mehr Information über die Art und Weise der Anwendung von **R**-Funktionen möchtest einfach die `?`-Funktion in Console eingeben oder über den View-Tab in RStudio zu der Funktionsbeschreibung zu gelangen.


## Symbole 

Eine der wichtigsten Optionen bei der Anpassung von Grafiken in **R** ist die Wahl der Symbole um Datenpunkte darzustellen. 
Das dafür genutzte Argumente `pch` erlaubt eine breite Auswahl an verschiedensten Formen an Symbolen. 
Um ein Symboltyp über `pch` auszuwählen gibt es zwei verschiedene Arten. 
Entweder durch die Angabe einer Zahl oder einer Zeichenfolge.

Symbole unterscheiden sich in ihrer Form und in der Art wie sie eingefärbt sind. 
Die Symbole 1 bis 14 haben nur einen Rand und sind immer leer, während die Symbole 15 bis 20 keinen Rand haben und immer gefüllt sind. 
Die Symbole 21 bis 25 haben sowohl einen Rand als auch eine Füllung. 
Um die Rahmenfarbe oder den Hintergrund für die Symbole 1 bis 20 festzulegen, verwende das Argument col. 
Bei den Symbolen 21 bis 25 legst du die Farbe des Rahmens mit col und die Farbe des Hintergrunds mit bg.


```{r echo = FALSE, fig.width = 3, fig.height = 3, fig.align= 'center'}
par(mar  = c(1, 1, 3, 1))
plot(x = rep(1:5 + .1, each = 5),
     y = rep(5:1, times = 5),
     pch = 1:25,
     xlab = "", ylab = "", xaxt = "n", yaxt = "n",
     xlim = c(.5, 5.5),
     ylim = c(0, 6),
     bty = "n", bg = "gray", cex = 1.4,
     main = "pch = ?"
     )
text(x = rep(1:5, each = 5) - .35,
     y = rep(5:1, times = 5),
     labels = 1:25, cex = 1.2
     )
```

Hier ein Beispiel dafür wie verschiedene Symbole und Farben Grafiken verändern können:

```{r echo = FALSE}
par(mfrow = c(2, 2))
par(mar = c(0, 1, 6, 1))
x.data <- rnorm(25)
y.data <- x.data + rnorm(25)
# Plot 1
plot(x = x.data, y = y.data, xaxt = "n", yaxt = "n", xlab = "", ylab = "", main = "pch = 2,\ncol = 'blue'", 
     pch = 2, col = "blue", cex = 1.5, cex.main = 1.2)
# Plot 2
plot(x = x.data, y = y.data, xaxt = "n", yaxt = "n", xlab = "", ylab = "", main = "pch = 16,\ncol = 'orchid2'", 
     pch = 16, col = "orchid2", cex= 1.5, cex.main = 1.2)
# Plot 3
plot(x = x.data, y = y.data, xaxt = "n", yaxt = "n", xlab = "", ylab = "", main = "pch = 21,\ncol = 'black',\nbg = 'orangered2", 
     cex= 1.5, cex.main = 1.2, 
     pch = 21, col = "black", bg = "orangered2")
# Plot 4
plot(x = x.data, y = y.data, xaxt = "n", yaxt = "n", xlab = "", ylab = "", main = "pch = 25,\ncol = 'pink3',\nbg = 'plum3", 
     cex= 1.5, cex.main = 1.2, 
     pch = 25, col = "pink3", bg = "plum3")
```


## Low-Level Plot-Funktionen

Die sogenannten Low-Level-Plot Funktionen erlauben es ein Element eines Plots zu verändern oder neue hinzuzufügen. 
Die wichtigsten und am meisten genutzten sind hierbei die folgenden: 


|Funktion                |Ergebnis                                                                |
|:-----------------------|:-----------------------------------------------------------------------|
|`points(x, y)`          |Fügt Punkte hinzu                                                       |
|`abline()`, `segments()`|Fügt Linien oder Segmente hinzu                                         |
|`arrows()`              |Fügt Pfeile hinzu                                                       |
|`curve()`               |Fügt eine Kurve hinzu, die eine Funktion darstellt                      |
|`rect()`,`polygon()`    |Fügt ein Rechteck oder eine willkürliche Form hinzu                     |
|`text()`, `mtext()`     |Fügt Text innerhalb der Handlung oder an den Rändern der Handlung hinzu |
|`legend()`              |Fügt eine Legende hinzu                                                 |
|`axis()`                |Fügt eine Achse hinzu                                                   |


Wenn man die Low-Level-Plot Funktionen verstehen will macht es Sinn mit einem leeren Plot anzufangen.

```{r}
plot(x = 0,                 
     xlab = "X-Achse", 
     ylab = "Y-Achse",
     xlim = c(0, 100), 
     ylim = c(0, 100),
     main = "Leerer Plot",
     type = "n")

```

## points() und Segments()

Um neue Punkte zu einem bestehenden Diagramm hinzuzufügen, verwende die Funktion points(). 
Die Funktion points() hat viele ähnliche Argumente wie die Funktion plot(), wie x (für die x-Koordinaten), 
y (für die y-Koordinaten) und Parameter wie col (Randfarbe), cex (Punktgröße) und pch (Symboltyp). 

Ein Beispiel anhand des vorher schon genutzen `mtcars`-Datenset. 
Für nähere Informationen einfach `?mtcars` eingeben. 
Hierbei wollen wir alle Autos hinsichtlich ihres Verbrauches in Miles-per-Gallon in Relation zu ihrem Gewicht abbilden. 
Dabei wollen wir die Autos je nach Gangschaltungstyp (Automatik und Manuell) farblich kennzeichen.

```{r, include = FALSE}
data(mtcars)
```


```{r}
plot(x = 0,                 
     xlab = "X-Achse", 
     ylab = "Y-Achse",
     xlim = c(10, 35), 
     ylim = c(1.2, 5.5),
     main = "Verbrauch pro 1000 lb",
     type = "n")

# Punkte hinzufügen Automatik
points(x = mtcars$mpg[mtcars$am == 0],
       y = mtcars$wt[mtcars$am == 0],
       pch = 16,
       col = "coral2")
# Punkte hinzufügen Manuell
points(x = mtcars$mpg[mtcars$am == 1],
       y = mtcars$wt[mtcars$am == 1],
       pch = 16,
       col = "steelblue3")
```


## abline() und segments()

Um einem Plot gerade Linien hinzuzufügen, verwendest du `abline()` oder `segments()`. `abline()` fügt eine Linie über den gesamten Plot hinzu, 
während `segments()` eine Linie mit definierten Anfangs- und Endpunkten hinzufügt.

|Argument         |Ergebnis                                                                |
|:----------------|:-----------------------------------------------------------------------|
|`h, v`           | Positionen der horizontalen und vertikalen Linien (nur für `abline()`) |
|`x0, y0, x1, y1` | Anfangs- und Endkoordinaten der Linien (nur für `segmente()`)          |
|`lty`            | Linientyp. 1 = durchgezogen, 2 = gestrichelt, 3 = gepunktet, ...       |
|`lwd`            | Breite der Linien, die durch eine Zahl angegeben wird                  |
|`col`            | Line Farbe                                                             |

Um das Aussehen der Linien zu ändern nutzt man das Argument `lty`

```{r ltytypes, echo = FALSE, fig.width = 4, fig.height = 4}
par(mar = c(3, 0, 6, 0))
plot(1,
     xlim = c(0, 7),
     ylim = c(0, 1),
     type = "n",
     xlab = "lty values",
     ylab = "",
     xaxt = "n",
     yaxt = "n",
     bty = "n",
     main = "")
abline(v = 1:6,
       lty = 1:6,
       lwd = 2)
mtext(1:6,
      side = 3,
      at = 1:6,
      cex = 1.5,
      line = 1)
mtext("lty = ...",
      side = 3,
      at = 3.5,
      line = 4,
      cex = 2)
```

Du kasnnst auch eine Regressionslinie (auch als Linie der besten Anpassung bezeichnet) zu einem Scatterplot hinzufügen, 
indem du ein Regressionsobjekt eingibst, das mit lm() als Hauptargument für abline() erstellt wurde.


```{r}
plot(x = mtcars$mpg,
     y = mtcars$wt,
     pch = 16,
     col = "coral2")

# Regressionslinie hinzufügen 
abline(lm(wt ~ mpg, data = mtcars), 
       lty = 2,
       col = "steelblue3")
```

## legend()

Die letzte Low-Level-Plotting-Funktion, die wir im Detail besprechen werden, ist legend(), die eine Legende zu einem Plot hinzufügt.

|Argument               |Ergebnis                                             |
|:----------------------|:----------------------------------------------------|
|`x, y`      |Die Koordinaten der Legende - z.B. `x = 0, y = 0` setzen den Text an die Koordinaten (0, 0).               |
|`labels`    |Ein String-Vektor, der den Text in der Legende angibt. Zum Beispiel wird `legend = c("Männlich, "Weiblich")|

Es ist ebenfalls möglich die Position der Legende durch Worte einzugeben wie `"topright"`, `"topleft"`. 
Zum Beispiel wird "unten rechts" die Legende immer in der rechten unteren Ecke der Handlung platziert.
Ein Beispiel an unserem Auto Datenset:


```{r}
plot(x = 0,                 
     xlab = "X-Achse", 
     ylab = "Y-Achse",
     xlim = c(10, 35), 
     ylim = c(1.2, 5.5),
     main = "Verbrauch pro 1000 lb",
     type = "n")

# Punkte hinzufügen Automatik
points(x = mtcars$mpg[mtcars$am == 0],
       y = mtcars$wt[mtcars$am == 0],
       pch = 16,
       col = "coral2")
# Punkte hinzufügen Manuell
points(x = mtcars$mpg[mtcars$am == 1],
       y = mtcars$wt[mtcars$am == 1],
       pch = 16,
       col = "steelblue3")
## Legende hinzufügen
legend("topright",
       legend = c("Automatik", "Manuell"),
       col = c('coral2', 'steelblue3'),
       pch = c(16, 16),
       bg = "white")
```



##  Multiple Plots 

Wie du im vorigen Beispiel gehen hast ist es ebenfalls möglich mehrere Plots in einer einzelnen Grafik abzubilden. 
Hier für gibt’s es bei Base-R Plots zwei Wege dieses zu erreichen. 
Am häufigsten wird dieses mit dem Parameter `par(mfrow)` und `par(mfcol)` erreicht. 
Gehen wir diese die beiden Funktionen durch. Mit den Parametern mfrow und mfcol kannst du eine Matrix von Plots in einem Plotraum erstellen. 
Beide Parameter nehmen einen Vektor der Länge zwei als Argument, also der Anzahl der Zeilen und Spalten in der resultierenden Plottmatrix.

Was ist also der Unterschied zwischen `par(mfrow)` und `par(mfcol)`? Der einzige Unterschied besteht darin, 
dass `par(mfrow)` sequentielle Plots zeilenweise in die Plottmatrix einfügt, während `par(mfcol)` sie spaltenweise füllt.

Der folgende Code erstellt beispielsweise die 2 x 2-Plotting-Matrix des vorigen Beispiels.

```{r}
# Es soll eine 2 x 2 Plotmatrix enstehen:
par(mfrow = c(2, 2))
par(mar = c(0, 1, 6, 1))
# Daten erschaffen
x.data <- rnorm(25)
y.data <- x.data + rnorm(25)
# Plot 1
plot(x = x.data, y = y.data, xaxt = "n", yaxt = "n", xlab = "", ylab = "", main = "pch = 2,\ncol = 'blue'", 
     pch = 2, col = "blue", cex = 1.5, cex.main = 1.2)
# Plot 2
plot(x = x.data, y = y.data, xaxt = "n", yaxt = "n", xlab = "", ylab = "", main = "pch = 16,\ncol = 'orchid2'", 
     pch = 16, col = "orchid2", cex= 1.5, cex.main = 1.2)
# Plot 3
plot(x = x.data, y = y.data, xaxt = "n", yaxt = "n", xlab = "", ylab = "", main = "pch = 21,\ncol = 'black',\nbg = 'orangered2", 
     cex= 1.5, cex.main = 1.2, 
     pch = 21, col = "black", bg = "orangered2")
# Plot 4
plot(x = x.data, y = y.data, xaxt = "n", yaxt = "n", xlab = "", ylab = "", main = "pch = 25,\ncol = 'pink3',\nbg = 'plum3", 
     cex= 1.5, cex.main = 1.2, 
     pch = 25, col = "pink3", bg = "plum3")

``` 

<!--chapter:end:07-plotten.Rmd-->

