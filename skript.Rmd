---
title: "Einführung in die R Grundlagen"
output: learnr::tutorial
runtime: shiny_prerendered
---


## Einleitung

 Skript ist als Teil der Bachelorveranstaltung Statistik der Wirtschaftswissenschaftlichen Fakultät an der Universität Göttingen entstanden und soll Studenten helfen auf eine einfache und direkte Art und Weise die wichtigsten Funktion der Statischen Programmiersprache **R** zu verstehen und anwenden zu können. Der Inhalt soll des Weiteren allen Studierenden helfen welche Interesse oder Fragen hinsichtlich **R**-Programmierung haben.

Die aktuellste Version des Skriptes, sowie die unterliegenden Source-Files, sind im Gitlab-Repository ["intro2r"](https://gitlab.gwdg.de/kruse44/intro2r) zu finden.

Dieses Skript wurde in [Rmarkdown](https://rmarkdown.rstudio.com/) und dem [learnr](https://rstudio.github.io/learnr/)-Package geschrieben und erstellt. Es handelt sich hierbei um einen Work-in-Progress und wird ständig durch Mitarbeiter des Lehrstuhl Statistik der Universität Göttingen erweitert und verbessert. Daher würden die Autoren sich sehr über Verbesserungsvorschläge, neue Ideen oder Fehlermeldungen freuen. Hierfür einfach eine E-Mail an folgende Adresse:

  &emsp;&emsp;&emsp; gitlab+kruse44-intro2r-10509-issue-@gwdg.de 

Das folgende Lehrmaterial ist und wird immer frei sein und kann unter einer [CC-BY-SA 4.0 Lizenz](https://creativecommons.org/licenses/by-sa/4.0/deed.de) verwendet, verbreitet und modifiziert werden.  Der Hauptautor der originalen Version ist [René-Marcel Kruse](https://www.uni-goettingen.de/en/610058.html)  (<a href="https://github.com/RMKruse/">Github@RMKruse</a>, <a href="https://gitlab.gwdg.de/kruse44">gitlab.gwdg@kruse44</a>) unter Mitwirkung von:

* Jasmin Schilling

Das Skript bezieht sich auf verschiedene Quellen, deren inhaltliche Aufarbeitung und Darstellung der Thematik, als Grundlage und Bezugspunkt beim Erstellen dieses Skriptes dienten. Hierbei sei vor allem auf folgende Quellen verwiesen, wobei es sich bei allen Quellen um Free-and-Open-Source Lehrinhalte der jeweiligen Autoren handelt:

* [Advanced R](http://adv-r.had.co.nz/) von [Hadley Wickham](http://hadley.nz/)
* [Merely Useful: Novice R](https://merely-useful.github.io/r/index.html) von [Madeleine Bonsma-Fisher et al.]()
* [R for Data Science](#https://r4ds.had.co.nz/) von [Hadley Wickham](http://hadley.nz/) und [Garrett Grolemund](https://twitter.com/statgarrett?lang=de)
* [Hands-On Programming with R](#https://rstudio-education.github.io/hopr/) von [Garrett Grolemund](https://twitter.com/statgarrett?lang=de)
* [Fundamentals of Data Visualization](#https://serialmentor.com/dataviz/) von [Claus O. Wilke](https://github.com/clauswilke)
* [YaRrr! The Pirate’s Guide to R](#https://bookdown.org/ndphillips/YaRrr/) von [Nathaniel D. Phillips](https://ndphillips.github.io/index.html)

Des Weiteren diente als Grundlage die Vorlesungsfolien des Statistik-Master Kurses "Introduction to Statistical Programming" von [Paul Wiemann](https://www.uni-goettingen.de/de/525900.html).





## Interaktion mit **R** und Rstudio

  Du hast jetzt zwei neue Programme auf eurem Rechner installiert und wollt loslegen, vorher ist es allerdings wichtig zu verstehen was der Unterschied zwischen R und Rstudio ist und wie du richtig mit ihnen umgehst. Wenn du deinem Rechner den Befehl geben wollt etwas für dich zu berechnen, dann musst du wissen wie du überhaupt mit ihm sprechen kannst. Hierbei stellt Rstudio einen Weg dar um mit dem Computer zu interagieren, während R die Sprache ist mit dem du mit dem Rechner kommuniziert.

Um nun mit und in R zu arbeiten rufst du Rstudio auf. WICHTIG! Nicht **R** selbst aufrufen (auch wenn dieses funktioniert  und einige alte hartgesottene Programmierer darauf schwören).

### Das User Interface von Rstudio
<!--TODO: Verlinkung auf Anhang für veränderungen von Rstudio-->
  Wenn du Rstudio zum ersten Mal öffnest wirst du von folgenem Bild begrüßt.

<!-- ![](images/rstudio_panes_klein.png) -->

  <img src="images/rstudio_panes_klein.png" width="600" height="450" alt="Rstudio">

  Was du hier siehst ist Rstudio in seiner Standard  Konfiguration. Im folgenden Abschnitt wirst du die 3 bzw. 4 Fenster oder auch Panes genannten Interaktionsfelder von Rstudio näher kennen lernen und verstehen wie du diese zu benutzen kannst. Hierbei gehen wir von links nach rechts vor.


### Die Console-Oberfläche
<!-- TODO: R definition für code chunks ändern, die ``` werden angezeigt. -->
  Das Consolen Fenster findest du in der Grundausführung von Rstudio auf der linken Seite und dient dir als direkte Integration  mit **R** und dadurch mit dem Computer. Jeder Code der in der Console eingegeben und durch Enter bestätigt wird, wird durchgeführt (engl. to run code).

<!-- ![](images/console1.png) -->
  <img src="images/console1.png" width="600" height="450" alt="Die Console">

  Du könnt in die R-Console einfache Rechenaufgaben eingeben und R wird dir wie eine Art Taschenrechner die Lösung der Aufgabe ausgeben.

```{r}
2 + 3
```

Die R-Console ist allerdings viel mehr als eine Art Taschenrechner, du  kannst hier dem Computer direkt über R-Code Befehle ausführen lassen.

Es ist Zeit für euren ersten selbst geschriebenen Code. Hierfür befehlt du dem PC die Worte "Hallo Welt!" widerzugeben. Dabei nutzt du den Befehl `print()` und gibst in die Klammer die Worte ein und führt den Code über das Drücken der Enter-Taste aus.
```{r, include=FALSE}
library(learnr)
```

```{r hallowelt, exercise=TRUE}

```

```{r hallowelt-solution}
print("Hallo Welt!")
```


Herzlichen Glückwunsch! Du hast hiermit deinen ersten R-Code geschrieben.

Allerdings ist es oft schwer und sehr langwierig gewisse Befehle jedes Mal neu einzugeben, sodass **R** bereits eine Vielzahl an implementierten Befehlen wie den oben genutzten  `print()` aufweist.
So kannst du ohne viel Programmierkenntnisse dem PC sagen Zahlen zu runden:

```{r}
round(2.5)
```

Oder die Uhrzeit eures Systems ausgeben lassen:

```{r}
Sys.time()
```

Wie du mit den verschieden Funktionen richtig umgehst, neue hinzufügt und eigene selbst schreibst wirst du im späteren Verlauf lernen.

### Die Script-Oberfläche

  <!-- TODO: Einleitung: Oft einfacher Über Skript zu gehen anstatt alles immer einzutippen -->

Das Eingeben von Code in die Console kann auf dauer mühsam sein, vor allem wenn du denselben Code wiederholst, komplexere Eingaben tätigst oder aufeinander folgende Operationen ausführen willst. Daher kommen wir noch von der Console zur Script- oder Source-Oberfläche.

Diese Oberfläche ist beim ersten Starten von Rstudio nicht zu sehen kann allerdings über den Reiter File --> New File --> R Script geöffnet werden. Alternativ kannst du einfach ein neues Skript über die Tastenkombination: Strg + Shift + N öffnen. Hierbei sei die Nutzung des Keyboard-Shortcuts zu bevorzugen, da diese Art und Weise schneller und direkter von statten geht.

Du wirst nun ein leeres Dokument sehen in welchem du den R-Code schreiben könnt ohne ihn gleich auszuführen. Diese Oberfläche bzw. das Skript dient also als eine Art Sammelstelle für euren Code. Das Skript kann ebenfalls gespeichert werden, sodass du in der Lage bist Code später (wieder) auszuführen oder ihn gar zu teilen oder später bei einer Seminar- oder Abschlussarbeit abzugeben.

  <!-- ![](images/source.png) -->

<img src="images/source.png" width="600" height="450" alt="Source Pane">

Gebt jetzt in dieses neue Fenster den Code aus dem letzten Abschnitt ein. Du wirst merken, dass dieser nicht sofort ausgeführt wird. Um den Code zu nutzen musst du diesen an die Console "schicken". Hierfür gibt es verschiedene Methoden. Hierfür kannst du zum einem den auszuführenden Code mit der Maus/Keyboard markieren und dann auf den Button "Run" klicken. Der viel einfachere und von uns vorgeschlagene Weg ist, einfach den Code durch das drücken von Strg + Enter (Linux, Windows) bzw. Command + Enter (Mac) auszuführen.

  Ein von dir geschriebenes Skript kannst du einfach über den Reiter File --> Save As abspeichern, sodass du das File jeder Zeit an dem Ort findest mit dem Namen "Euer_Skript_Name.R".

### Die Environment-Oberfläche

<!-- TODO: Verweis auf das Kapitel für Objekte etc einfügen -->
Das in der Ausgangskonfiguration sich rechts oben befindliche Environment-Feld dient verschiedener Aufgaben. In aller erster Linie sind dort alle Objekte zu finden welche gerade in R definiert sind. Was das genau bedeutet und wie man so etwas macht werden wir im Kapitel XXXXXXX näher untersuchen.

<!-- ![](images/environment_history.png) -->

<img src="images/environment_history.png" width="600" height="450" alt="History Pane">

Als kleines Beispiel führe den folgenden Code in eurer Rstudio Instanz aus:


```{r, eval = TRUE}
1:10
x <- 1:10
```

<!-- <!-- ![](images/environment_beispiel.png) -->

<!-- <img src="images/environment_beispiel.png" width="300" height="200" alt="Environment Pane"> -->


Hierbei erstellst du eine Sequenz an Zahlen von 1 bis 10. Im ersten Beispiel wird diese Sequenz ausgegeben, während beim zweiten Beispiel du der Variable `x` die Werte der Sequenz von 1 bis 10 zuweist. Allerdings erscheint nun rechts im Environment Feld der Eintrag für `x.` Dies bedeutet dass nun wann immer du in der R Console oder im Skript die Größe `x` benutzt die zugewiesene Sequenz von 1 bis 10 wiedergibt.

<!-- ![](images/console_beispiel.png) -->

<img src="images/console_beispiel.png" width="600" height="450" alt="">


  Der zweite Tab im Fenster "History" wird der von dir zuvor in der Console evaluierte  Code chronologisch gespeichert um dir eine Anlaufstellen für die Fehlersuche zu bieten oder zu verstehen was du beim letzten Mal in **R** gemacht habt.

<!-- ![](images/history_beispiel.png) -->

<img src="images/history_beispiel.png" width="600" height="450" alt="">


  Zu guter Letzt bietet die Environment-Oberfläche das manuelle Einlesen von Daten über den Button-Import Dataset. In dem du diesen Button bedienst öffnet sich ein Dropdown Menü, in dem du die verschiedenen Arten von nicht in **R** integrierten einlesbaren Daten auswählen kannst. Dieses Menü erlaubt dir so das einlesen und bearbeiten von Daten aus

  - Text-Datein (.txt, .csv, ...)
  - Excel (.xls, .xlsc, .xml, ...)
  - SPSS
  - STATA
  - SAS

somit bist du in der Lage Daten zu bearbeiten welche von Nutzern mit beschränkten Computerkenntnis stammen.


### Die Output-Oberfläche
Die letzte Oberfläche in Rstudio dient dazu dir verschiedene Arten von Information über eure Daten, eure Dateien und genutzten Funktionen darzubieten.


<!-- ![](images/outputs.png) -->

<img src="images/outputs.png" width="600" height="450" alt="">



Der erste Tab “Files” dient als eine Art eingebaute Version des Filemanagment Systems eures Computers. Hierbei erhälst du einen direkten Zugriff auf die Dateien und Ordnerstruktur auf eurem Rechner. Der Tab “Plots” wird alle von dir in der aktuellen Sitzung erstellten Grafiken beinhalten. 
Der dritte Tab “Packages” stellt eine Liste von sogenannten Packages dar welche auf eurem Computer installiert sind. Packages sind herunterladbare Sammlungen oder Pakete an bereits geschriebenen Funktionen, welche du nutzen kannst anstatt dazu gezwungen zu sein eure eigenen Funktionen zu schreiben.
Der vierte Tab “Help” stellt, wie der Name schon sagt die in **R** integrierte Hilfe dar. In diesem Fenster kannst du nach Funktionen oder Packages suchen und deren Beschreibungen, sowie Beispiele für die korrekte Nutzung finden.



<!-- ![](images/help_beispiel.png) -->

<img src="images/help_beispiel.png" width="600" height="450" alt="">



Eine andere Art mit der Hilfe von Rstudio umzugehen ist die Nutzung der `?`-Funktionalität. Hierbei kannst du einfach in der Console nach der Dokumentation einzelner Funktionen suchen. Dabei kannst du mit einem `?` wenn du den Namen einer Funktion kennst direkten nach dessen Dokumentation suchen
```{r, eval = FALSE}
?sd

# Oder auch möglich als
help(mean)
```

Falls du nicht direkt die Lösung deines Problems findet, die Erklärung/Beispiel nicht verständlich genug ist oder dein Problem zu komplex für die interne Rstudio-Hilfe ist gibt es verschiedene Arten um an Hilfe zu kommen.

Eine der größten, wichtigsten und oft hilfreichsten Plattformen ist <a href="https://stackoverflow.com/" title="s">StackOverflow</a>

### Teste dein **R** Wissen
```{r, include=FALSE}
library(learnr)
```
*Aufgabe 1:*

```{r aufgabe1_1, echo=FALSE}
question("Welche(r) der folgenden Panes gibt es nicht in Rstudio",
         answer("History"),
         answer("Console"),
         answer("Browser", correct = TRUE),
         answer("Input", correct = TRUE),
         answer("Script"),
         random_answer_order = TRUE
)
```

*Aufgabe 2:*

```{r aufgabe1_2, echo=FALSE}
question("Welche der folgenden Methoden erlaubt es dir Information zu **R** Funktionen zu erhalten?",
         answer("?-Operator", correct = TRUE),
         answer("??-Operator", correct = TRUE),
         answer("help()", correct = TRUE),
         answer("googlen ;-)", correct = TRUE),
         answer("StackOverflow", correct = TRUE),
         random_answer_order = TRUE
)
```


*Aufgabe 3:*

```{r aufgabe1_3, echo=FALSE}
question("In welchem Pane findest du die Variablen welche in R zugewiesen worden sind?",
         answer("Environment", correct = TRUE),
         answer("Console"),
         answer("Outputs"),
         answer("Script"),
         random_answer_order = TRUE
)
```


<!---------------------------------------------------------- Kapitel 2 ---------------------------------------------------------->


## Einführung in **R**-Programmierung {#kapitel3}
    
Nach dem wir im letzten Kapitel uns R und dessen IDE Rstudio genauer angeschaut haben und dabei erste Beispiele für das Programmieren in R gesehen haben wird es Zeit uns in diesem Kapitel genauer mit der Programmierung in R zu befassen.
Du wirst lernen was Objekte in R sind, wie man Funktionen richtig anwendet und neue Funktionen durch das installieren durch Packages R hinzufügt. Des Weiteren wirst du lernen wie man Code richtig liest, was gute Konditionen beim Schreiben von Code sind und wie du einen guten Workflow in eure Arbeitsweise einarbeitet.

  
### Zuweisung und Recalling Objekts
  
Im letzten Kapitel haben wir ein Beispiel gehabt, in dem wir einer Variable `x` die Sequenz von 1 bis 10 zugewiesen haben. Durch diese Zuweisung war die Sequenz an die Variable `x` gebunden, sodass jedes Mal wenn `x` in der Console abgerufen worden ist die Sequenz von 1 bis 10 wiedergeben worden ist. Generell kann man R wie einen Taschenrechner nutzen wie im ersten Abschnitt beschrieben, allerdings können wir immer wie bei dem Sequenz Beispiel Rechnungen, Werte oder andere Dinge gewissen Ausdrücken wie der Variablen `X` zuweisen um sie so zu speichern.
Dieses zuweisen erfolgt in **R** immer über den `<-` Operator. Hierbei müssen Variablen nicht unbedingt einzelne Variablen wie `x` sein, sie können auch Namen tragen. Als Beispiel des Zuweisens von verschieden Werten zu verschiedenen Variablen

  
```{r}
  x <- 13
  x
```

Hierbei wurde dem Variablen `x` der Wert 13 zugewiesen und im nächsten Schritt wurde der Variablen `x` erneut ein neuer Wert 2 zugewiesen.
  
```{r}
  x <- 2
  x
```

Du kannst hierbei sehen, dass durch die zweite Zuweisung die erste Zuweisung aufgehoben worden ist und durch die neue ersetzt worden ist. Solltet du deinem Code Kommentare hinzufügen wollen, welche nicht durch **R** ausgeführt wird, nutzt du zu erst das Symbol `#`. Wobei es einfacher ist erst deinen Kommentar zu formulieren, diesen zu markieren und durch das Drücken der Tastenkombination `Strg + Shift + c` wird dieser Part automatisch zu einem Kommentar.
  
```{r}
# Kleines Beispiel eines String-Vectors

  beispiel <- "hallo welt!"
  beispiel
```
Das dritte Beispiel zeigt dir, dass ebenfalls ganze Namen oder andere Zeichenkombinationen einen Wert zugewiesen bekommen können. Dir fällt ebenfalls auf, dass das dritte Beispiel keinen Zahlenwert darstellt, sondern Text einen sogenannten String. Zu den verschiedenen Datentypen in **R** kommen wir im nächsten Abschnitt
  
Es gibt allerdings einige Namen für Variablen welche du nicht in **R** nutzen solltest, da diese zu Problem führen (können). Die Namen der Objekte dürfen nicht mit `^, !, $, @, +, -, /, or *`: beginnen.                

### Teste dein **R** Wissen
 
**Aufgabe 1** 
 
*Wie du sicherlich weißt, ist die Antwort auf alle Fragen im Leben 42. Daher erstelle ein Objekt mit dem Namen `Antwort` und weise diesem Objekt den Wert `42` zu.* 

```{r antwort42, exercise=TRUE}

```

```{r antwort42-solution}
Antwort <- c(42)
# Oder:
Antwort <- 42
```

**Aufgabe 2**

*Ein Kommilitone will einem Objekt einen Wert zuweisen, weiß aber nicht ob der Name zulässig ist. Welche(r) (wenn überhaupt) der folgenden Objektnamen ist (sind) ungültig?*
```{r aufgabe1, echo=FALSE}
question("",
  answer("dieser"),
  answer("DIESER"),
  answer("d1eser"),
  answer("die.ser"),
  answer("D!ESER!", correct = TRUE),
  random_answer_order = TRUE
)
```

**Aufgabe 3**

*Schaue dir den untenstehenden Code an. Was wird **R** nach der dritten Zeile zurückgeben? Mache eine Vorhersage und teste den Code selbst.*

```{r,eval=FALSE}

x <- 100
x + 50
x

```

```{r xeval, exercise=TRUE}

```

```{r xeval-solution}
100
```

<!---------------------------------------------------------- Kapitel 2.1 ---------------------------------------------------------->


## Daten Strukturen in R

Zu Beginn schauen wir uns allerdings erst einmal an in welchen Formen (Strukturen) Daten in **R** gespeichert werden können.

Die Basisdatenstrukturen von **R** können nach ihrer Dimensionalität (1 x d, 2 x d oder n x d) und danach organisiert werden, ob sie homogen (alle Inhalte müssen vom gleichen Typ sein) oder heterogen (die Inhalte können von unterschiedlichem Typ sein) sind. Daraus ergeben sich die fünf in der Datenanalyse an den häufigsten verwendeten Datentypen:

| Dimension      | Homogen             | Heterogen     |
| -------------- |:--------------------| :-------------|
| 1 x d          |  	Atomarer Vektor  | List          |
| 2 x d          | Matrix              |   Data Frame  |
| n x d          | Array               |    -          |

<!-- TODO: Verweis auf das Kapitel mit String Zuweisung -->


Eine Besonderheit von R ist es, dass es keine 0 x d (0-dimensionalen) oder skalaren Typen kennt. Einzelne Daten die wir als Menschen als Skalare wahrnehmen würden, sind trotzdem für R ein Vektor mit der Länge 1.

Wir starten mit dem einfachsten und wahrscheinlich wichtigsten Daten Typ in **R** Vektoren. Ein Vektor besteht entweder homogen aus der gleichen elementaren oder "atomaren" Klassen (sog. Atomare Vektor) oder heterogen als Listen.
 

### Vektoren 
  
In diesem Buch behandeln wir vier sogenannter atomaren (also kleinst mögliche Form) Objekten in **R**. Jede der verschiedenen Formen verlangt eine andere Form der Notation Hierbei handelt es sich um
  
  1. Logical
  2. Integer
  3. Double
  4. Character
  
Atomare Vektoren werden normalerweise mit` c()`, kurz für combine, erzeugt.
  
#### Logicals
  
Bei den **Logicals** handelt es sich wie der Name schon verrät um logische Aussagen. Logische Werte nehmen einen von zwei möglichen Werten an `TRUE` oder `FALSE`, bzw. deren Abkürzung in Form von `T` und `F`. 

```{r logicalBSP}
logicalBSP <- c("FALSE", "TRUE", T, F)
```
  
#### Doubles
  
Bei den sogenannten **Doubles** handelt es sich um Zahlenwerte. Hierbei können die Werte in decimal-, scientific- und in hexadecimalschreibweise angegeben werden. Es gibt außerdem noch besondere Zahlenwerte welche ebenfalls zu den Doubles gehören. Hierbei handelt es sich um Unendlich: Inf bzw. -Inf und um ie Angabe "Not a Number" `NaN`.
```{r doublesBSP}
doublesBSP <- c(42.42, 13.37, 6.66)
```  
#### Integers
  
Die **Integers** gehören genau wie die Doubles zu den Zahlenwerten, die Besonderheit in der Notation liegt darin, dass jedem Zahlenwert ein "L" angehängt wird (`1.2345L`)
```{r intBSP}
integerBSP <- c(2L,6L,1L,3L,3L)
```  
#### Characters
  
Die Klasse der **Characters** umfasst alle eingaben von Buchstaben/Zeichenkombinationen. Beider Eingabe werden diese immer mit Anführungsstrichen (" " oder ' ' ) umschlossen. Beispiel: `"Hallo Welt!"`   
```{r strBSP}
stringBSP <- c("Hallo Welt!", "Ich bin R Code!")
```  
Korrekterweise sei an dieser Stelle auf zwei weitere atomare Objektarten hingewiesen, die complex- und raw-Objekte. Die Klasse "complex" umfasst alle Eingaben von komplexen Zahlen, während die Klasse "raw" nur im Rahmen von binären Daten genutzt wird. Diese beiden Arten werden in komplexeren Zusammenhängen behandelt, welche dir wahrscheinlich nicht im Rahmen der Bachelorveranstaltungen über den Weg laufen und werden daher nicht behandelt. Falls du interesse an diesem Thema hast empfehlen wir das Buch: [Advanced R von Wickham](https://adv-r.hadley.nz/)

### Listen

Der große Unterschied zwischen atomaren Vektoren und Listen ist der, dass Listen alle möglichen verschiedenen Typen von Daten beinhalten können. Listen werden im Gegensatz zu Vektoren mit dem Befehl `list()` erstellt.

```{r listenBSP1}

lst1 <- list(3L, "Hallo", c(13.9, 42.22223), c(T, F, TRUE))

```

Interessanterweise ist es mögliche Listen in Listen zu speichern, was es ermöglicht sogenannte rekursive Vektoren zu erstellen:

```{r list2}

listception <- list(list(list(list())))
  
``` 

#### Eingabe von Vektoren

Die Eingabe von Daten per Hand kann sehr langwierig sein, vor allem wenn zum Beispiel die Folge von 1 bis 1000 als Vektor speichern will. Daher gibt es Möglichkeiten Einträge über Befehle von **R** selbst die zu erstellen. Hier sind ein paar der nützlichsten Methoden, die dir das Arbeiten mit **R** erleichtern:

| Funktion                         | Beispiel                          | Ergebnis                            |
|:---------------------------------|:----------------------------------|:------------------------------------|
| `c(a, b, ...)`                   |`c(1, 5, 9)`                       |`r c(1, 5, 9)`                       |
| `a:b`                            |`1:5`                              |`r 1:5`                              |
|`seq(from, to, by, length.out)`   |`seq(from = 0, to = 6, by = 2)`    |`r seq(from = 0, to = 6, by = 2)`    |
|` rep(x, times, each, length.out)`|`rep(c(7, 8), times = 2, each = 2)`|`r rep(c(7, 8), times = 2, each = 2)`|


#### Faktoren

Eine spezielle Form der Vektoren sind Faktoren, welche die Kategorien oder Klassifikationen von
Vektoren angeben, welche also Kategoriale Daten darstellt. Durch die Anwendung der factor()-Funktion
auf einen Vektor mit Characters bzw. Zeichenketten (Strings), verwandelt die einfachen Zeichen in Faktoren
um. Als Beispiel erschaffen wir einen Vektor mit Bezeichnung für Frau (w) und Mann (m) und verwandeln
diese in Faktoren um.

```{r faktorBSP1}

sex <- rep(c("w","m"), times = 3)
sex <- factor(sex)
sex

```

Zwei nützliche Funktionen bei der Arbeit mit Faktoren sind die Checks `class()` und `levels()`. Die erste
Funktion fragt einen Vektor welche Art von Daten vorliegen, während die zweite Funktion die verschiedenen
Ausprägungen des Faktors darstellt

```{r faktorBSP2}

class(sex)
levels(sex)

```
Faktoren sind nützlich, wenn du die möglichen Werte kennst, die eine Variable annehmen kann, auch wenn
du nicht alle Werte in einem bestimmten Datensatz weißt. Die Verwendung eines Faktors anstelle eines
Zeichenvektors (Strings) macht es offensichtlich, wenn einige Gruppen keine Beobachtungen enthalten:

```{r faktorBSP3}

summary(sex)

```

### Matrizen und Arrays

Atomare Vektoren und Listen sind wie oben bereits erwähnt als 1 x d Objekte zu verstehen. Fügen wir den Objekten nun eine weiter Dimension hinzu, so betrachten wir Matrix und Arrays. Ähnlich zu den Listen existieren zur Erstellung von Matrizen und Arrays eigene Befehle, `matrix()` und respektive `array()`.

#### Matrizen

Das besondere bei Matrizen im Gegensatz zu den 1-dimensionalen Vektoren und Listen ist, dass sie mehrere Spezifikationen benötigen um erschaffen zu werden. So muss bei der Nutzung von `matrix()` definiert werden, welche Werte in der Matrix zu finden sein sollen, des Weiteren wie die Dimensionen der Matrix auszusehen haben also die Anzahl der Reihen (`nrow`) und Spalten(`ncol`). Hier ein kleines Beispiel:

```{r matrixBSP}

m <- matrix(c(1,2,3,4,5,6), ncol = 2, nrow = 3)
m

```
Du kannst sehen, dass zu erst ein Atomarer Vektor mithilfe des Combine-Befehls eingegeben wird, gefolgt von der Anzahl der Spalten mit 2 und der Anzahl der Reihen mit 3.

#### Arrays
 
Der Vollständigkeit halber  hier ein Beispiel wie man Arrays in **R** erschafft, allerdings werden keine Arrays in der Einführung Vorlesung der Statistik behandelt.

Ähnlich zu der Logik hinter dem Matrix Befehl müssen mehr Eingaben getätigt werden wenn man ein Array Objekt kreieren will als nur die Datenpunkte selbst, zu sehen am folgenden Beispiel

```{r arrayBSP}

a <- array(1:12, c(2, 3, 2))
a
```
Der Array Befehl folgt folgender Struktur, man definiert zum einen die abzubildenden Datenpunkte, hier in unserem Beispiel durch die Sequenz von 1 bis 12 `1:12`, gefolgt von der Eingabe der gewünschten Dimension, in diesem Beispiel durch den Vektor `c(2,3,2)`resultierend in einem Array mit den Dimensionen 2 x 3 x 2.


#### Data.Frames

Data Frames sind die zweidimensionale Version einer Liste. Es sind sehr flexible und nützliche Datenstruktur für die Datenanalyse. Man kann einen Data Frame als eine Art **R** Äquivalent zur Excel-Tabelle vorstellen, da er Daten in einem ähnlichen Format speichert.

Data Frames gruppiert Vektoren in einer zweidimensionalen Tabelle. Jeder Vektor wird zu einer Spalte in der Tabelle. Folglich kann jede Spalte eines Datenrahmens einen anderen Datentyp enthalten.

Die Erstellung eines Data Frames von Hand erfordert viel Arbeit, sodass die Eingabe einfacher über die `data.frame()` Funktion geschieht. Nutze einfach eine beliebige Anzahl von Vektoren, die jeweils durch ein Komma getrennt sind. Jeder Vektor sollte einem Namen entsprechen, der den Vektor beschreibt. Die `data.frame()`-Funktion macht jeden Vektor zu einer Spalte des neuen Datenrahmens

```{r datafBSP}

df <- data.frame(lat = c("51.5454", "53.1438", "35.7034"),
                 lon = c("9.9055", "8.2138", "139.7532"), 
                 value = c("Göttingen", "Oldenburg", "Tokyo"))
df

```
Jeder Vektor muss hierbei die gleiche Länge haben.


#### Names

Es macht oft Sinn nicht nur den Objekten, sondern auch Variablen in R-Objekten Namen zu geben. Ein
Beispiel: 

```{r namesBSP1}
alter <- c(13, 42, 39)
names(alter)

names(alter) <- c("Chris", "Henny", "Paul")
alter
```

Wir haben hier also einen Vektor der verschiedenen Altersangabe beinhält. Wir können nun jedem Eintrag
einen Namen mit der `name()`-Funktion zuweisen, in diesem Fall drei verschiedene Namen. Nun wenn der
Vektor abgerufen wird, werden die Namen mit den dazugehörigen Alterszahlen angegeben.
Listen und Matrizen können genauso wie atomare Vektoren ebenso Namen aufweisen. Bei Listen ist dies
sehr hilfreich, da es so einfacher ist auf bestimmte Elemente in den Listen zuzugreifen

```{r namesBSP2}
alter <- list("Chris" = 13, Henny = 42, Paul = 39)
alter
```

Wir man hier sehen kann, enthält die Liste nun drei verschiedene Objekte mit jeweils einem anderen Namen.
Interessanterweise kann man den Namen mit aber auch ohne Anführungszeichen eingeben, dies liegt daran,
dass wenn der Name aus mehreren Worten besteht der Name von `" "` umschlossen sein muss.
Des Weiteren sind die Namen hilfreich auf einzelne Elemente der Liste zuzugreifen

```{r namesBSP3}
alter$Chris
```

Aber zu diesem bestimmten auswählen von Teildaten und Subsets mehr im späteren Abschnitt zur Daten Manipulation.
Namen bei Matrizen haben auf Grund ihrer anderen Dimensionalität eine andere Struktur. Matrizen haben
immer Column (Spalten) und Row (Reihen) spezifische Namen. Diese Namen kann man nur die Nutzung
der Funktionen `colnames()` und `rownames()` festlegen und verändern oder in dem man über den Befehl
`dimnames()` gleich beide zusammen definiert.

```{r namesBSP4}

m <- matrix(1:4, nrow = 2, ncol = 2)
dimnames(m) <- list(c("a", "b"), c("c", "d"))
m

colnames(m) <- c("h", "f")
rownames(m) <- c("x", "z")
m
```


### Teste dein **R** Wissen

**Aufgabe 1**

*Erstelle einen Vektor `x` von 1 bis 5 in allen drei dir bekannten weisen:  1. Nur mithilfe des `c()`-Operators, 2. durch den `a:b`-Befehl und 3. durch `seq()`*

```{r seq15, exercise=TRUE}

```

```{r seq15-solution}
# 1. c()
x <- c(1, 2, 3, 4, 5)
# 2. a:b
x <- 1:5
#3 seq()
x <- seq(1, 5)
# bzw.
x <- seq(from = 1, to = 5, by = 1)
```


**Aufgabe 2**

*Erstelle einen Vektor, der die Zahlen von 1 bis 5, 5 Mal wiederholt. Das heißt [1, 2, 3, 4, 5, 1, 2, 3, 4, 5, ...]. Die Länge des Vektors sollte 25 betragen!*

```{r seq25, exercise=TRUE}

```

```{r seq25-solution}
rep(1:5, times = 5)
```


**Aufgabe 3**

*Welche der folgenden ist KEINE homogene Datenstruktur*

```{r quizdata, echo=FALSE}
question("",
  answer("(Atomarer) Vektor"),
  answer("Matrix"),
  answer("List", correct = TRUE),
  answer("Array"),
  answer("Dataframe", correct = TRUE),
  random_answer_order = TRUE
)
```



**Aufgabe 4**

*Erstelle eine Liste `x` welche einen Namens-Vektor der drei Namen Larissa, Johan und Sarah, und welche den Vektor der jeweiligen Alter 29, 21, 31 beinhält*


```{r liste1ex, exercise=TRUE}

```

```{r liste1ex-solution}
x <- list(namen = c("Larissa", "Johan", "Sarah"),
          alter = c(29, 21, 31))
```


**Aufgabe 5**

*Erstelle einen Dateframe `dfm` welche eine Variable `x` beinhält welche eine Sequenz von 1 bis 3 beinhält, welche mit 10 multipliziert wird*

```{r dataframex1, exercise=TRUE}

```

```{r dataframex1-solution}
dfm <- data.frame(
  x = 1:3 * 10
)
```

*Nun füge dem Dataframe `dfm` eine Größe `y` hinzu, welche eine Matrix 3 x 3 darstellt, welche die Werte von 1 bis 9 beinhält. Füge außerdem eine Größe `z` hinzu welche in sich selbst ein Dataframe ist, welche die Variablen `a` als Sequenz von 3 auf 1, die Variable `b` welche die Namen Paul, Sina und Lea beinhält.*

```{r dataframex2, exercise=TRUE}

```

```{r dataframex2-solution}

dfm$y <- matrix(1:9, nrow = 3)
dfm$z <- data.frame(a = 3:1, b = c("Paul", "Sina", "Lea"))

```



<!---------------------------------------------------------- Kapitel 2.2 ---------------------------------------------------------->




## Grundlegende **R**-Funktionen {#kapitel3.3}
  
**R** kommt von Hause aus mit verschiedenen bereits implementierten Funktionen wie die bereits vorgestellten `mean()`, `round()`, `print()` und vielen mehr. Im folgenden Abschnitt werden wir durch ein paar der wichtigsten in **R** implementierten Funktionen durchgehen um dir ein Gefühl dafür zu geben wie du mit **R**-Funktionen umgehen musst und wie du effektiv mit **R** arbeiten kannst.
  
### Mathematische Operationen

Bisher wissen Sie, wie man grundlegende arithmetische Operationen wie `+` (Addition), `-` (Subtraktion) und `*` (Multiplikation) auf Skalaren ausführt. Glücklicherweise macht es **R** genauso einfach, arithmetische Operationen auf numerischen Vektoren durchzuführen:

Bis jetzt hast du **R** wie einen Taschenrechner nutzen und einfache arithmetische Operationen durchführen können.Glücklicherweise macht es **R** genauso einfach, arithmetische Operationen auf numerischen Vektoren durchzuführen. 

```{r arithBSP}

x <- c(1, 2, 3, 4, 5)
y <- c(5, 6, 7, 8, 9)

```

Wenn du eine Operation mit einem Vektor und einem Skalar durchführst, wendet R den Skalar auf jedes einzelne Element des Vektors an.

```{r vekaddBSP}
# Addition mit Skalaren
a + 100

1:5 + 10
```

Wenn du eine Operation auf zwei Vektoren der gleichen Länge anwenden willst funktioniert  es recht einfach. R wendet die Operation auf beide Vektoren Element für Element an. Als Beispiel was damit gemeint ist:
  
```{r vektormath}
x + y
y - x
(x + y) / 10

```

### Deskriptive Statistik

Die folgenden Befehle stellen eine Zusammenfassung der wichtigsten und für dich im Laufe des Studiums wichtigsten Statistiken.

| Funktion | Beispiel | Output |
|:-------------------------|:----------------------|:-----------------------|
| `sum(x), product(x)`     |    `sum(1:10)` |`r sum(1:10)`     |
| `min(x), max(x)`         |    `min(1:10)`|`r min(1:10)`    |
| `mean(x), median(x)`     |    `mean(1:10)`     | `r mean(1:10)` |
| `sd(x), var(x), range(x)`|    `sd(1:10)` | `r sd(1:10)` |
| `quantile(x, probs)`     |    `quantile(1:10, probs = .2)`|`r quantile(1:10, probs = .2)`     |
| `summary(x)`|    `summary(1:10)`|`Min = 1.00. 1st Qu. = 3.25, Median = 5.50, Mean = 5.50, 3rd Qu. = 7.75, Max = 10.0`     |



### Missing Values

Ein Problem, welches auftreten kann, wenn man mit echten Daten arbeitet ist, dass es entweder falsche oder gar fehlende Werte auftreten. Sollte in deinen Daten Fehlende Werte auftreten, kommen leider vielen grundlegende Statistiken zu nicht verlässlichen Ergebnissen. Der folgende Code gibt beispielsweise NA als Ergebnis zurück, weil ein NA-Wert im Datenvektor vorhanden ist:

```{r}
a <- c(0, 1, NA, 3, 4)
mean(a)
```

Glücklicherweise biete **R** allerdings eine Möglichkeit, um mit `NAs` in den Daten umzugehen. So kann man entweder bei der Anwendung einer Funktion auf die Daten ein weiteres Argument an die Funktion weitergeben, welche dieser befiehlt, alle `NAs` in den Daten zu ignorieren bei diesem Argument handelt es sich um den Ausdruck `na.rm`, so bald dieses gleich `TRUE` gesetzt wird, ignoriert **R** alle `NAs`. 

```{r}

mean(a, na.rm = TRUE)

```

Eine andere Art mit diesem Problem umzugehen ist es, alle Nas in den Daten zu löschen. Hierfür erstellt man einfach ein neues **R**-Objekt wobei man die **R**-Funktion `na.omit()` auf die Daten anwendet. Als Beispiel:

```{r}
b <- na.omit(a)
mean(b)
``` 

Sollte die in der base-**R** Version enthalteten Funktionen nicht für deine Arbeit aussreichen, gibt es zwei Möglichkeiten wie du mit diesem Problem umgehst:

  1. Finden eines **R**-Packages welches Funktionen beinhält welche es erlaubt dein Problem zu lösen
  2. Eigene Funktionen zu schreiben
  
  
### Packages

Ein Package ist eine Sammlung von Code, welches von einer anderen Person oder Gruppe geschrieben worden ist. Meistens sind Pakete dazu gedacht, ein bestimmtes Problem zu lösen, also Funktionen zusammenzufassen, die mit einem bestimmten datenwissenschaftlichen Problem zusammenhängen (z.B. Data Wrangling, Visualisierung, Inferenz). Jeder kann ein Paket schreiben, und man kann Pakete von vielen verschiedenen Orten bekommen.
  
#### Wie installiere ich Package?

Die Installation eines Pakets bedeutet einfach das Herunterladen des Packages auf deinen Computer. Es gibt verschiedene Wege, neue Pakete zu installieren. Der einfachste und gebräuchlichste Weg ist das Herunterladen aus dem Comprehensive **R** Archive Network (CRAN). CRAN ist der zentrale Speicherort für **R**-Pakete. Um ein neues **R**-Paket von CRAN zu installieren, kannst du einfach den Befehl `install.packages("name")` ausführen, wobei "name" der Name des Pakets ist.
  
```{r packages, eval = FALSE}
install.packages("name")
```
Einige Pakete sind Bündel von Packages. Zum Beispiel das "tidyverse"-Package, welches viele einzelne Pakete für Daten Wrangling und Visualisierung zusammenfasst, so dass Sie bei der Installation von einem einzelnem Package dem tidyverse eigentlich acht verschiedene Packages installiert.
  
```{r installationtidyverse, eval = FALSE}
# Installation des Package Bundles tidyverse
  install.packages("tidyverse")
  
```
  
#### Wie nutze ich Packages?

Jetzt weißt du wie man Packages installiert, aber wie nutzt du diese? Um Packages zu nutzen welche nicht Teil der Base-R Version sind, müssen diese erst in die aktive **R** Session geladen werden. Hierfür nutzt du einfach den Befehl library("name"). Nehmen wir das Beispiel des Packages `ggplot2` welches Teil des tidyverse ist. Dazu nutzt du einfach den folgenden Code:
    
```{r, }
# Laden des Packages ggplot2
  library(ggplot2)
```
Und schon bist du in der Lage die im package beinhalteten Funktionen zu nutzen um z.B. `ggplot2` Fall ansprechenden graphische Analysen anzufertigen:
    
```{r ggplotBSP}
  
  gg <- ggplot(midwest, aes(x=area, y=poptotal)) + 
    geom_point(aes(col=state), size=3) +
    geom_smooth(method="lm", col="firebrick", size=2) + 
    coord_cartesian(xlim=c(0, 0.1), ylim=c(0, 1000000)) + 
    labs(title="Fläche Vs Population", 
         subtitle="US-Midwest dataset", 
         y="Population", x="Fläche", 
         caption="Midwest Demographics")
  
# Achsenbeschriftung ändern
  gg + scale_x_continuous(breaks=seq(0, 0.1, 0.01), 
                          labels = sprintf("%1.2f%%", 
                                           seq(0, 0.1, 0.01))) + 
    scale_y_continuous(breaks=seq(0, 1000000, 200000), 
                       labels = function(x){paste0(x/1000, 'K')})
  
```

### Teste dein **R** Wissen

*Aufgabe 1*

*Erste einen Vektor `x` der den Durchschnitt einer Sequenz von 1 bis 10 beinhält.*
```{r grundex1, exercise=TRUE}

```

```{r grundex1-solution}
x <- mean(1:5)
```


*Aufgabe 2*

*Die berühmte Göttinger Band „Die Randdichten“ haben für alle ihrer Konzerte des letzten Jahres ein Dataframe erstellt in dem sie aufgeschrieben haben wie viele Auftritte sie pro Monat hatte und wie viele Fans ihre Konzerte im jeweiligen Monat besucht haben.*

```{r, echo = FALSE}
randdichten <- data.frame(
                          monat = c("Jan", "Feb", "Mar", "Apr", "Mai", "Jun", "Jul", "Aug", "Sep", "Okt", "Nov", "Dez"),
                          auftritte = sample(x = 1:10, size = 12, replace = TRUE),
                          besucher = sample(x = 10:200, size = 12, replace = TRUE)
)
```

```{r summarize1}
summary(randdichten)
```

*Berechne die durchschnittliche, minimale, maximale und gesamte Besucherzahl aller Konzerte des letzten Jahres*

```{r grundex2, exercise=TRUE}

```

```{r grundex2-solution}
# Durchschnittliche
mean(randdichten$besucher)
# Minimale
min(randdichten$besucher)
# Maximale
max(randdichten$besucher)
# Gesamte
sum(randdichten$besucher)
```



## Eigene Funktionen

Wenn du merkst, dass du einige Aufgaben immer wieder durchführen musst und dafür Abfolgen von Code immer Kopieren und Einfügen musst, oder dass es keine Funktionen existieren welche eine bestimmte Aufgabe die du gelöst sehen willst lösen kann, solltest du überlegen eigene Funktionen zu schreiben.

Funktionen werden mit der `function()`-Anweisung definiert und wie alles andere als **R**-Objekte gespeichert. Ein Beispiel einer "leeren" Funktion

```{r}
f <- function() {
  ## Eine leere Funktion
  }

```

Als nächstes können wir eine Funktion erstellen, die tatsächlich einen nicht-trivialen Funktionskörper hat.
```{r}

f <- function() {
  cat("Hello, world!\n")
}
f()

```
Der letzte Aspekt einer Grundfunktion sind die Funktionsargumente. Dies sind die Optionen, die der Benutzer angeben kann. Für diese Grundfunktion können wir ein Argument hinzufügen, das bestimmt, wie oft "Hallo, Welt!" auf der Konsole ausgegeben wird.

```{r}

f <- function(num) {
       for(i in seq_len(num)) {
               cat("Hello, world!\n")
       }
}

f(2)

```



### Kontroll-Strukturen

Bei einigen Aufgaben müssen sich einige Berechnungen wiederholen oder sie sind abhängig von bestimmten
Bedingungen. Selbst denselben Befehl immer wieder abzutippen ist im besten Fall langweilig, und im
schlimmsten Fall sehr aufwendig. Deswegen erlaubt es R, wie viele andere Programmiersprachen auch,
repetitive Aufgaben zu automatisieren


### For-Loops

Wenn du Rechnungen mehrfach wiederholen musst eignet sich dafür der `for()`-Befehl, der die folgende
allgemeine Form besitzt:

```{r forBSP1, eval=FALSE}
for (variable in vector) {
  # Aufgabe
}
```

Der Ablauf hierbei ist immer gleich, wird eine bestimmte Kondition (condition) erfüllt, wird ein bestimmter
**R** Befehl ausgeführt (expr). Man kann diese If-Anfrage durch eine Else-Condition erweitern, welche bei
nicht Erfüllung der Bedingung einen anderen Befehl ausführt.

```{r forBSP2}
for(i in 1:5){
  print(i)
}
```

### If-Else

Du wirst beim Schreiben von eigenen Funktionen in die Situation kommen, in der eine Funktion bedingt
auf ein Ereignis ein bestimmtes Ergebnis reagieren muss. Diese bedingten Abfragen sehen in **R** so aus

```{r ifBSP1, eval=FALSE}
# Einfacher Fall
  if (condition) {
# expr
}

# Entweder Oder Fall
if (condition) {
  # expr
} else {
  # expr
}
```

Der Ablauf hierbei ist immer gleich, wird eine bestimmte Kondition (condition) erfüllt, wird ein bestimmter
**R** Befehl ausgeführt (expr). Man kann diese If-Anfrage durch eine Else-Condition erweitern, welche bei
nicht Erfüllung der Bedingung einen anderen Befehl ausführt

```{r ifBSP2}
x <- c(6)

if (x == 6) { # Wenn x = 6, dann
  print("x gleich 6")
}

if (x == 5) { # Wenn x = 5, dann
  print("x gleich 5")
} else { # Wenn x nicht gleich 5 dann
  print("x ist ungleich 5")
}
```

### While-Loops

Die while-Schleife dient dazu, eine Abfolge von Anweisungen mehrfach auszuführen, solange eine Bedingung
erfüllt ist

```{r whileBSP1, eval=FALSE}
while (condition) {
  # Expr
}
```

Ein Beispiel für diese Form der wiederholten Ausführung eines Befehls ist hier zu sehen.

```{r whileBSP2}
i <- 1
while (i < 6) {
  print(i)
  i = i+1
}
```

### return

Zu guter letzt lernst du noch den befehl `return()`kennen. Dieser Befehl sagt deiner **R**-Funktion, dass wenn die funktion durchgeführt wird es möglich ist einer Variable dazu einen Wert zu zuweisen. Als Beispiel:

Hierfür schreiben wir eine Funktion welche zwei Element als Input nimmst und diese mit einander addiert. 

```{r, eval = FALSE}

addtwo <- function(x, y){
  z <- x + y
}

```

Führen wir nun diese Funktion aus, so werden `x` und `y` mit einander addiert und wiedergegeben. Nun willst du aber zum Beispiel diesen Wert in einem Objekt Speichern nennen wir es einfach `v`. Hierfür nutzt man einfach die folgende Funktionsstruktur.

```{r, eval = FALSE}

addtwo <- function(x, y){
  z <- x + y
  return(z)
}

```

gebe einfach beliebige Zahlen für die beiden Inputs ein. Du wirst sehen, dass kein Ergebnis widergegeben wird, allerdings dass wenn du `v` eingibst und abrufst das Ergebnis ausgegeben wird.

```{r addtow, exercise=TRUE}
v <- addtwo(x = 2, y = 3)
v
```


### Teste dein **R** Wissen

*Die Freunde Aisouda, Henny und René haben sich nach dem Studium in der Göttinger Innenstadt eine Eisdiele gekauft. Um zu wissen wie viele Kugeln Eis sie vorbereiten müssen, müssen die Drei die wahrscheinlich nachgefragt Menge vorhersagen. René schlägt dabei vor, dass sie pro erwarteter Sonnenstunde 100 Kugeln Eis verkaufen werden.*

*Schreibe eine Funktion `Eismenge` die als Input die morgigen Sonnenstunden (`s`) nimmt und die zu produzierende Menge an Eis berechnet. Gehe davon aus, dass es am morgigen Tag 11 Sonnenstunden geben wird. Berechne mit der Funktion die Eismenge.*
```{r function1, exercise=TRUE}

```

```{r function1-solution}
Eismenge <- function(s) {
  x <- s * 100
  return(x)
}

Eismenge(s = 11)
```

*Henny und Aisouda haben allerdings schon begonnen Flyer in der Stadt zu verteilen und sind der Meinung, dass die Anzahl der verteilten Flyer ebenfalls einen Einfluss auf die Menge an verkaufen Eiskugeln hat. Beide gehen darüber hinaus  davon aus, dass die wahre Beziehung zwischen den Größen wie folgt sei: (Sonnenstunden x log(Temperatur) x 100)/Preis*

*Schreibe eine Funktion die als Input die morgigen Sonnenstunden (`s`), Temperatur (`t`) und Preis (`p`) nimmt und die zu produzierende Menge an Eis berechnet. Gehe davon aus, dass es am morgigen Tag 11 Sonnenstunden geben wird, es 32 Grad warm wird und eine Kugel 1.50 € Kostet. Berechne mit der Funktion die Eismenge.*

```{r function2, exercise=TRUE}

```

```{r function2-solution}
Eismenge <- function(s, t, p) {
  return((s * log(t) *100)/p)
}

Eismenge(s = 11, t =32, p = 1.5)
```
<!----------------------------------------------------------  Kapitel 3 ---------------------------------------------------------->

##  Daten

In diesem Kapitel wirst du lernen wie man externe Daten in **R** einließt, wie man mit diesen Daten arbeitet,
sie verändert, anpasst und exportiert.
  
### Einlesen von Daten 

Daten können aus verschiedenen externen Quellen und Dateiformaten in **R** eingelesen werden. Es gibt ein
paar Hauptfunktionen, die Daten in **R** einlesen.

  * `read.table()`, `read.csv()`, zum Einlesen von Tabellendaten
  * `source()`, zum Einlesen von **R**-Code-Dateien
  * `dget()`, zum Einlesen von **R**-Code-Dateien
  * `load()`, zum Lesen in gespeicherten Arbeitsbereichen
  * `unserialize()`, zum Lesen einzelner R-Objekte in binärer Form

Hierbei sei darauf hingewiesen, dass es noch viele weitere **R** Packages gibt, welche es dir erlauben Daten in
**R** einlesen zu können.
Parallel zu den verschiedenen Funktionen zum Einlesen von Daten in **R** gibt es diese Funktionen welche es
dir erlauben Daten zu schreiben
    
  * `write.table()`, `write.csv()` zum Schreiben von Tabellendaten in Textdateien (z.B. CSV) oder Verbindungen
  * `writeLines()`, zum zeilenweisen Schreiben von Zeichendaten in eine Datei oder Verbindung
  * `dump()`, zum Ausgeben einer textlichen Darstellung mehrerer **R**-Objekte
  * `dput()`, zur Ausgabe einer textlichen Darstellung eines **R**-Objektes
  * `save()`, zum Speichern einer beliebigen Anzahl von **R**-Objekten im Binärformat (möglicherweise komprimiert) in eine Datei.
  * `serialize()`, zum Konvertieren eines **R**-Objektes in ein Binärformat zur Ausgabe auf eine Verbindung (oder Datei).
    
### Das readr-Package

Ein explizit für das Einlesen erschaffenes **R** Package ist das reader-Package welches explizit zum Einlesen
von großen Datenfiles gedacht ist. Das Package ersetzt die im vorigen Kapitel beschriebenen Funktionen
`read.table()` und `read.csv()` mit den Funktionen `read_table()` bzw. `read_csv()`.

Generell gibts es allerdings ein paar Gründe wieso du lieber auf die Funktionen des `readr`-Packages zurückgreifen
solltest.

  * Durch den effizienteren Code hinter den Funktonen ist das Einlesen von Daten um ein Vielfaches schneller, was sich vor allem bei größeren Datenfiles bemerkbar macht.
  * Die `readr`-Funktionen sind generell auch reproduzierbar. Während die Base-**R** Funktionen Eigenheiten des jeweiligen Betriebssystems des Computers übernehmen, sind `readr`-Funktionen System-agnostisch.


### Speichern von Daten


Wir bereits zu Beginn des Kapitels dargestellt existieren analog zu den Funktionen welche Daten in **R** einlesen Funktionen, welche Daten exportieren bzw. abspeichern. Du kannst Objekte, wie die im vorigen Abschnitt erstellte Liste `x` durch die Nutzung der Funktion `write.table()` bzw. `write.csv()` speichern. Wie jede Funktion in **R** die wir bisher begegnet sind, haben auch diese Argumente die bestimmten Einfluss auf Art und Weise wie die Funktion durchgeführt wird. 

Um nun `x` beispielhaft als CSV-Datei abzuspeichern musst du folgendes machen:

```{r savecsvBSP, eval = FALSE}

write.csv(x, file = "beispiel.csv", row.names = FALSE)

```

Der Aufbau der Argumente hat folgende Struktur. Zunächst solltest du `write.csv()` den Namen des **R**-Objektes geben, das du gespeichert haben möchtest. Als nächstes solltest du einen Dateinamen für deine Datei angeben. **R** wird diesen Namen ziemlich wörtlich nehmen, also stell sicher, dass du eine Erweiterung

**R** wandelt deine Liste in eine Klartextdatei in eine CSV-Datei um, in welcher Werte durch Komma getrennt sind und speichert die Datei in deinem Arbeitsverzeichnis. Du fragst dich vielleicht was dein Arbeitsverzeichnis ist? Nun das klären wir im nächsten Abschnitt.


<!----------------------------------------------------------  Kapitel 3 ---------------------------------------------------------->



    
### Daten Selektion 

Es ist oft wichtig für bestimmte Operationen nur einen Teil der Daten, also ein Subset, zu betrachten und
zu bearbeiten. Diese sogenannte Subsettig von **R** Objekten kann in Base-**R** mithilfe von drei verschiedenen
Operatoren gemacht werden. Diese drei Operatoren sind `[]`, `[[]]` und `$`.
Der `[]` Operator selektiert ein Teil der Daten und gibt das Subset in derselben Objekt Klasse aus wie das
Originale. Der `[[]]` hingegen kann nur einzelne Element aus Listen oder Dataframe subsetten und das
resultierende Objekt ist nicht unbedingt aus der selben Objekt Klasse wie das übergeordnete. Schlussendlich
der `$` Operator kann genutzt werden um Elemente durch Nutzung ihres Names auszulesen.
Zuerst betrachten wir wie man Subsetting mit einem Vektor macht
  
### Subsetting von Vektoren

Zu Beginn die Anwendung des `[` Operators auf Vektoren. Hierbei kann man sehen, dass entweder einzelne
Elemente ausgelesen werden können, ganze Folgen oder bestimmte beliebige Positionen

```{r subsetvektor1}
foo <- c("rot", "gruen", "blau", "blau", "gelb", "rot")

# Nur das erste Element des Vektors
foo[1]

# Die ersten vier Elemente
foo[1:4]

# Der erste, dritte und letzte Eintrag
foo[c(1, 3, length(foo))]

```

Oft sehr interessant ist auch die logische Abfrage von Inhalten:

```{r subsetvektor2}
  
# Alle nicht roten Elemente
foo[foo != "rot"]

```

### Subsetting von Matrizen

Das subsetten einer Matrix erfolgt denselben Regel wie das Subsetten der Vektoren, wobei hier die abzufragenden
Positionen anstatt mit einer Angabe auf Grund der zwei-Dimensionalität durch zwei Angaben
anzugeben ist. Hier ein Beispiel anhand der im Kapitel 3 erschaffenen Matrix was damit gemeint ist

```{r subsetmatrix1}
m <- matrix(c(1,2,3,4,5,6), ncol = 2, nrow = 3, byrow = TRUE)
m

# Abfrage des Elements in der zweiten Reihe und der ersten Spalte
m[2,1]

```

Wenn man nun allerdings anstatt eines Elementes, alle Elemente einer Reihe oder Spalte abfragen will kann
man die jeweilige Row bzw. Column Angabe frei lassen. Beispiel hier:

```{r subsetmatrix2}
# Alle Elemente der ersten Reihe
m[1, ]

# Alle Elemente der ersten Spalte
m[ , 1]

```

### Subsetting von Listen

Listen können in **R** in drei verschiedenen Arten gesubsettet werden. Hierfür nutzt man die oben genannten drei verschiedenen Operatoren. Um die drei verschiedenen Arten zu illustrieren erschaffen wir zu erst eine Beispielsliste

```{r subsetliste1}
x <- list(foo = 1:3, faa = "hallo", faz = 0.3)

```

Eine der einfachsten und bequemsten Arten Listen zu subsetten ist die Benutzung des `$` Operators. Der Grund hierfür ist, dass wenn du den Namen der Zielliste eingibst, gefolgt vom Operator, kannst du durch das Betätigen der Tabulator Taste Rstudios Autovervollständigung nutzen. Dabei werden alle Elemente einer Liste aufgeführt und du kannst einfach das gewünschte Element über die Pfeiltasten auswählen.

```{r subsetliste2}

x$foo

x$faa

```

Ähnlich zum Subsetten der Matrizen und Vektoren, können Listen ebenso mit dem `[]`- bzw. `[[]]`-Operator gesubsettet werden. Wenn du also das erste Element der Liste auswählen willst kannst du einfach wie in folgendem Beispiel machen 

```{r subsetliste3}
x[[1]]

```

Ebenso ist es wieder möglich in Kombination mit dem `[[]]`-Operator mit Hilfe der Namen der Elemente die Liste zu subsetten.

```{r subsetliste4}
x[["foo"]]

```

Schlussendlich ist es ebenso möglich mehrere Elemente der Liste auszuwählen. Hierfür nutze einfach den `[]` oder `[[]]`-Operator und setze gebe einen Vektor an, welche die Elemente bestimmt. Allerdings sei hierbei darauf hingewiesen, dass je nach dem welchen der beiden Operatoren du nutzt verschieden Elemente ausgewählten werden .Zum einfacheren Verständnis das folgende Beispiel:

```{r subsetliste5}

# Das Zweite und das dritte Element der Liste
x[c(2,3)]

# Der dritte Eintrag des ersten Elements 
x[[c(1,3)]]
```

```{r subsetliste6}


```


### Teste dein **R** Wissen

**Aufgabe 1**

*Korrigiere jeden der folgenden allgemeinen Dataframe-Subsetzfehler*


```{r, include=FALSE}
data(mtcars)
```

```{r, eval =FALSE}
mtcars[mtcars$cyl = 4, ]
mtcars[-1:4, ]
mtcars[mtcars$cyl <= 5]
mtcars[mtcars$cyl == 4 | 6, ]
```

```{r filterex1, exercise=TRUE}

```

```{r filterex1-solution}
mtcars[mtcars$cyl == 4, ]       # benutze `==`             
mtcars[-c(1:4), ]                 # benutze `-(1:4)`          
mtcars[mtcars$cyl <= 5, ]        # `,` fehlt
mtcars[mtcars$cyl == 6, ]  # benutze `mtcars$cyl == 6` 
```


**Aufgabe 2**

*Warum gibt mtcars[1:20] einen Fehler zurück? Wie unterscheidet es sich von den ähnlichen mtcars[1:20, ]. Führe beide Befehle aus.*

```{r filterex2, exercise=TRUE}

```





<!-- ### **Exkurs**: Workspace Management {-} -->

<!-- Wie im letzten Abschnitt besprochen gibt es ein sogenanntes "Arbeitsverzeichnis". Dieses Verzeichnis ist nichts anderes als der Ort auf deinem Rechner in dem **R** Daten speichern oder Graphiken hin exportieren wird. Du kannst dein Verzeichnis frei wählen und jeder Zeit verändern. Wenn du wissen willst wo genau auf deinem Rechner **R** gerade sein Arbeitsverzeichnis hat, nutze einfach den Befehl `getwd()`.  -->

<!-- ```{r getwd, eval =FALSE} -->

<!-- getwd() -->

<!-- ``` -->

<!-- Wenn du nun dein Arbeitsverzeichnis ändern möchtest, verwende  die Funktion `setwd()`. Wenn ich zum Beispiel mein Arbeitsverzeichnis in einen bestehenden OwnCloud-Ordner namens Intro2R ändern wollte, würde ich den folgenden Code ausführen: -->

<!-- ```{r setwd, eval=FALSE} -->

<!-- setwd(dir = "/Users/rkruse/OwnCloud/Intro2R") -->
<!-- ``` -->

<!-- <!-- Quelle: https://github.com/ndphillips/ThePiratesGuideToR/blob/master/09-workingwithdata.Rmd --> -->

<!-- Einige sehr hilfreiche Funktionen die dir bei der regelmäßiger Nutzung **R** helfen relativ einfach eine Übersicht über deine Daten und die von dir kreierten Funktionen zu erhalten sind in der folgenden Tabelle aufgeführt. -->

<!-- | Code| Description|  -->
<!-- |:------------------------|:----------------------------------| -->
<!-- |`ls()`|Alle Objekte im aktuellen Arbeitsbereich anzeigen| -->
<!-- |`rm(a, b, ..)`|Entfernt die Objekte `a`, `b`... aus deinem Arbeitsbereich| -->
<!-- |`rm(list = ls())`|Entfernt *alle* Objekte in Ihrem Arbeitsbereich| -->
<!-- |`getwd()`|Gibt das aktuelle Arbeitsverzeichnis zurück | -->
<!-- |`setwd(file = "dir)`|Ändert das Arbeitsverzeichnis auf einen bestimmten Dateiort | -->
<!-- |`list.files()`|Gibt die Namen aller Dateien im Arbeitsverzeichnis zurück | -->
<!-- |`write.table(x, file = "mydata.txt", sep)`|schreibt das Objekt `x` in eine Textdatei namens `mydata.txt`. Definieren Sie, wie die Spalten mit `sep` getrennt werden (z.B.; `sep = ","` für eine Komma-getrennte Datei und `sep = \t"` für eine Tabulator-getrennte Datei).| -->
<!-- |`save(a, b, .., file = "myimage.RData)`|Speichert Objekte `a`, `b`, ... in `Myimage.RData` | -->
<!-- |`save.image(file = "myimage.RData")`|Speichert *alle* Objekte in Ihrem Arbeitsbereich in `myimage.RData`.| -->
<!-- |`load(file = "myimage.RData")`|Lädt Objekte in die Datei `myimage.RData`| -->
<!-- |`read.table(file = "mydata.txt", sep, header)`|Liest eine Textdatei namens `mydata.txt`, definiert, wie Spalten mit `sep` getrennt werden (z.B. `sep = ","` für kommagetrennte Dateien und `sep = "\t"` für tabulatorgetrennte Dateien), und ob es eine Kopfspalte mit `header = TRUE` gibt.| 





<!---------------------------------------------------------- Kapitel Plotten ---------------------------------------------------------->



## Plotten

Oft ist es wichtig Zusammenhänge nicht nur in Zahlen, sondern ebenso graphisch darzustellen. Das folgende Kapitel zeigt dir wie man verschiedene Arten von wichtigen grundlegenden Plots in **R** erstellt und wie man diese in einer Art und Weise kreiert, sodass man sie ohne Probleme in Seminar- oder Abschlussarbeiten zu nutzen.

Dieses Kapitel wird sich nur mit den in der base-**R** Version enthaltenen Plot-Funktionen befassen. Wir lassen bewusst **R**-Packages wie `ggplot2` oder `plotly` aus, solltest du dich allerdings für die Funktionalität dieser Packages und der damit verbundenen Verbesserung der Möglichkeiten der graphischen Darstellung interessieren, empfehlen wir dir die https://socviz.co/ und https://rkabacoff.github.io/datavis/ . 

  

### Plot-Funktion
  
Die einfachste Möglichkeit einen Plot in **R** zu erstellen ist die **R**-base Funktion `plot()` zu nutzen. In der Standard Einstellung erstellt der Befehl ein Streudiagramm basierend auf den beiden Input Vektoren für die Abszissen- sowie der Ordinatenwerte.  
  
```{r einfachplot}  
  
plot(x = 1:5,
     y = 1:5)

```

Erklärung der wichtigsten Argumente der `plot()`-Funktion

| Argument| Beschreibung| 
|:------------|:-------------------------------------------------|
|`x, y`|Vektoren gleicher Länge, die die x- und y-Werte der Punkte angeben|
|`type`| Art der Handlung. `"l"` bedeutet Linien, `"p"` bedeutet Punkte, `"b"` bedeutet Linien und Punkte, `"n"` bedeutet kein Plotten|
|`main`, `xlab`, `ylab`| Strings, die den Titel der Handlung beschriften, und x- und y-Achsen|
|`xlim`, `ylim`| Grenzen zu den Achsen. Zum Beispiel setzt `xlim = c(0, 100)` das Minimum und das Maximum der x-Achse auf 0 und 100.|
|`pch` | Eine ganze Zahl, die den Typ der Zeichensymbole angibt (siehe `?points` und Abschnitt unten), oder eine Zeichenkette, die Symbole als Text angibt. Zum Beispiel erzeugt `pch = 21` einen zweifarbigen Kreis, während `pch = "P"` das Zeichen `"P"` zeichnet. Um all die verschiedenen Symboltypen zu sehen, führen Sie ``Punkte` aus.
|`col`| Hauptfarbe der Plottsymbole. Zum Beispiel wird `col = "rot"` rote Symbole erzeugen.|
|`cex`| Ein numerischer Vektor, der die Größe der Symbole angibt (von 0 bis Inf). Die Standardgröße ist 1. `cex = 4` macht die Punkte sehr groß, während `cex = .5` sie sehr klein macht. |


```{r}

plot(x = 1:5,
     y = 1:5,                        
     type = "b",                      
     main = "Etwas hübscherer Plot",
     xlab = "x-Achse",
     ylab = "y-Achse ",                
     col = "red",                     
     pch = 16,                        
     cex = 1)                         

```

Generell gilt es hier, wie bei allen anderen Funktionen in **R**, wenn du mehr Information über die Art und Weise der Anwendung von **R**-Funktionen möchtest einfach die `?`-Funktion in Console oder über den View in Rstudio zu der Funktionsbeschreibung zu gelangen.

### Symbole 

Eine der wichtigsten Optionen bei der Anpassung von Grafiken in **R** ist die Wahl der Symbole um Datenpunkte darzustellen. Das dafür genutze Argumente `pch` erlaubt eine breite Auswahl an verschiedensten Formen an Symbolen. 
Um ein Symboltyp über `pch` auszuwählen gibt es zwei verschiedene Arten. Entweder durch die Angabe einer Zahl oder einer Zeichenfolge.

Symbole unterscheiden sich in ihrer Form und in der Art wie sie eingefärbt sind. Die Symbole 1 bis 14 haben nur einen Rand und sind immer leer, während die Symbole 15 bis 20 keinen Rand haben und immer gefüllt sind. Die Symbole 21 bis 25 haben sowohl einen Rand als auch eine Füllung. Um die Rahmenfarbe oder den Hintergrund für die Symbole 1 bis 20 festzulegen, verwende das Argument col. Bei den Symbolen 21 bis 25 legst du die Farbe des Rahmens mit col und die Farbe des Hintergrunds mit bg.


```{r echo = FALSE, fig.width = 3, fig.height = 3, fig.align= 'center'}
par(mar  = c(1, 1, 3, 1))
plot(x = rep(1:5 + .1, each = 5),
     y = rep(5:1, times = 5),
     pch = 1:25,
     xlab = "", ylab = "", xaxt = "n", yaxt = "n",
     xlim = c(.5, 5.5),
     ylim = c(0, 6),
     bty = "n", bg = "gray", cex = 1.4,
     main = "pch = ?"
     )
text(x = rep(1:5, each = 5) - .35,
     y = rep(5:1, times = 5),
     labels = 1:25, cex = 1.2
     )
```

Hier ein Beispiel dafür wie verschiedene Symobole und Farben Grafiken verändern können:

```{r echo = FALSE}
par(mfrow = c(2, 2))
par(mar = c(0, 1, 6, 1))
x.data <- rnorm(25)
y.data <- x.data + rnorm(25)
# Plot 1
plot(x = x.data, y = y.data, xaxt = "n", yaxt = "n", xlab = "", ylab = "", main = "pch = 2,\ncol = 'blue'", 
     pch = 2, col = "blue", cex = 1.5, cex.main = 1.2)
# Plot 2
plot(x = x.data, y = y.data, xaxt = "n", yaxt = "n", xlab = "", ylab = "", main = "pch = 16,\ncol = 'orchid2'", 
     pch = 16, col = "orchid2", cex= 1.5, cex.main = 1.2)
# Plot 3
plot(x = x.data, y = y.data, xaxt = "n", yaxt = "n", xlab = "", ylab = "", main = "pch = 21,\ncol = 'black',\nbg = 'orangered2", 
     cex= 1.5, cex.main = 1.2, 
     pch = 21, col = "black", bg = "orangered2")
# Plot 4
plot(x = x.data, y = y.data, xaxt = "n", yaxt = "n", xlab = "", ylab = "", main = "pch = 25,\ncol = 'pink3',\nbg = 'plum3", 
     cex= 1.5, cex.main = 1.2, 
     pch = 25, col = "pink3", bg = "plum3")
```


### Low-Level Plot-Funktionen

Die sogenannten Low-Level-Plot Funktionen erlauben es ein Element eines Plots zu verändern oder neue hinzuzufügen. Die wichtigsten und am meisten genutzten sind hier bei die folgenden: 


|Function                |Outcome                                                                 |
|:-----------------------|:-----------------------------------------------------------------------|
|`points(x, y)`          |Fügt Punkte hinzu                                                       |
|`abline()`, `segments()`|Fügt Linien oder Segmente hinzu                                         |
|`arrows()`              |Fügt Pfeile hinzu                                                       |
|`curve()`               |Fügt eine Kurve hinzu, die eine Funktion darstellt                      |
|`rect()`,`polygon()`    |Fügt ein Rechteck oder eine willkürliche Form hinzu                     |
|`text()`, `mtext()`     |Fügt Text innerhalb der Handlung oder an den Rändern der Handlung hinzu |
|`legend()`              |Fügt eine Legende hinzu                                                 |
|`axis()`                |Fügt eine Achse hinzu                                                   |


Wenn man die Low-Level-Plot Funktionen verstehen will macht es Sinn mit einem leeren Plot anzufangen.

```{r}
plot(x = 0,                 
     xlab = "X-Achse", 
     ylab = "Y-Achse",
     xlim = c(0, 100), 
     ylim = c(0, 100),
     main = "Leerer Plot",
     type = "n")

```


### points() und Segments()

Um neue Punkte zu einem bestehenden Diagramm hinzuzufügen, verwende die Funktion points(). Die Funktion points() hat viele ähnliche Argumente wie die Funktion plot(), wie x (für die x-Koordinaten), y (für die y-Koordinaten) und Parameter wie col (Randfarbe), cex (Punktgröße) und pch (Symboltyp). 

Ein Beispiel anhand des vorher schon genutzen `mtcars`-Datenset. Für nähere Informationen einfach `?mtcars` eingeben. 
Hierbei wollen wir alle Autos hinsichtlich ihres Verbrauches in Miles-per-Gallon in Relation zu ihrem Gewicht abbilden. Dabei wollen wir die Autos je nach Gangschaltungstyp (Automatik und Manuell) farblich kennzeichen.

```{r, include = FALSE}
data(mtcars)
```


```{r}
plot(x = 0,                 
     xlab = "X-Achse", 
     ylab = "Y-Achse",
     xlim = c(10, 35), 
     ylim = c(1.2, 5.5),
     main = "Verbrauch pro 1000 lb",
     type = "n")

# Punkte hinzufügen Automatik
points(x = mtcars$mpg[mtcars$am == 0],
       y = mtcars$wt[mtcars$am == 0],
       pch = 16,
       col = "coral2")
# Punkte hinzufügen Manuell
points(x = mtcars$mpg[mtcars$am == 1],
       y = mtcars$wt[mtcars$am == 1],
       pch = 16,
       col = "steelblue3")
```


### abline() und segments()

Um einem Plot gerade Linien hinzuzufügen, verwendest du `abline()` oder `segments()`. `abline()` fügt eine Linie über den gesamten Plot hinzu, während `segments()` eine Linie mit definierten Anfangs- und Endpunkten hinzufügt.

|Argument         |Outcome                                                                 |
|:----------------|:-----------------------------------------------------------------------|
|`h, v`           | Positionen der horizontalen und vertikalen Linien (nur für `abline()`) |
|`x0, y0, x1, y1` | Anfangs- und Endkoordinaten der Linien (nur für `segmente()`)          |
|`lty`            | Linientyp. 1 = durchgezogen, 2 = gestrichelt, 3 = gepunktet, ...       |
|`lwd`            | Breite der Linien, die durch eine Zahl angegeben wird                  |
|`col`            | Line Farbe                                                             |

Um das Aussehen der Linien zu ändern nutzt man das Argument `lty`

```{r ltytypes, echo = FALSE, fig.width = 4, fig.height = 4}
par(mar = c(3, 0, 6, 0))
plot(1,
     xlim = c(0, 7),
     ylim = c(0, 1),
     type = "n",
     xlab = "lty values",
     ylab = "",
     xaxt = "n",
     yaxt = "n",
     bty = "n",
     main = "")
abline(v = 1:6,
       lty = 1:6,
       lwd = 2)
mtext(1:6,
      side = 3,
      at = 1:6,
      cex = 1.5,
      line = 1)
mtext("lty = ...",
      side = 3,
      at = 3.5,
      line = 4,
      cex = 2)
```

Du kasnnst auch eine Regressionslinie (auch als Linie der besten Anpassung bezeichnet) zu einem Scatterplot hinzufügen, indem du ein Regressionsobjekt eingibst, das mit lm() als Hauptargument für abline() erstellt wurde


```{r}
plot(x = mtcars$mpg,
     y = mtcars$wt,
     pch = 16,
     col = "coral2")

# Regressionslinie hinzufügen 
abline(lm(wt ~ mpg, data = mtcars), 
       lty = 2,
       col = "steelblue3")
```


### legend()

Die letzte Low-Level-Plotting-Funktion, die wir im Detail besprechen werden, ist legend(), die eine Legende zu einem Plot hinzufügt.

|Argument               |Outcome                   |
|:----------------------|:----------------------------------------------------|
|`x, y`      |Die Koordinaten der Legende - z.B. `x = 0, y = 0` setzen den Text an die Koordinaten (0, 0).               |
|`labels`    |Ein String-Vektor, der den Text in der Legende angibt. Zum Beispiel wird `legend = c("Männlich, "Weiblich")|

Es ist ebenfalls möglich die Position der Legende durch Worte einzugeben wie `"topright"`, `"topleft"`. Zum Beispiel wird "unten rechts" die Legende immer in der rechten unteren Ecke der Handlung platziert.
Ein Beispiel an unserem Auto Datenset:


```{r}
plot(x = 0,                 
     xlab = "X-Achse", 
     ylab = "Y-Achse",
     xlim = c(10, 35), 
     ylim = c(1.2, 5.5),
     main = "Verbrauch pro 1000 lb",
     type = "n")

# Punkte hinzufügen Automatik
points(x = mtcars$mpg[mtcars$am == 0],
       y = mtcars$wt[mtcars$am == 0],
       pch = 16,
       col = "coral2")
# Punkte hinzufügen Manuell
points(x = mtcars$mpg[mtcars$am == 1],
       y = mtcars$wt[mtcars$am == 1],
       pch = 16,
       col = "steelblue3")
## Legende hinzufügen
legend("topright",
       legend = c("Automatik", "Manuell"),
       col = c('coral2', 'steelblue3'),
       pch = c(16, 16),
       bg = "white")
```

### Teste dein **R** Wissen



### Multiple Plots 

Wie du im vorigen Beispiel gehen hast ist es ebenfalls möglich mehrere Plots in einer einzelnen Grafik abzubilden. Hier für gibt’s es bei Base-R Plots zwei Wege dieses zu erreichen. Am häufigsten wird dieses mit dem Parameter `par(mfrow)` und `par(mfcol)` erreicht. Gehen wir diese die beiden Funktionen durch. Mit den Parametern mfrow und mfcol kannst du eine Matrix von Plots in einem Plotraum erstellen. Beide Parameter nehmen einen Vektor der Länge zwei als Argument, also der Anzahl der Zeilen und Spalten in der resultierenden Plottmatrix.

Was ist also der Unterschied zwischen `par(mfrow)` und `par(mfcol)`? Der einzige Unterschied besteht darin, dass `par(mfrow)` sequentielle Plots zeilenweise in die Plottmatrix einfügt, während `par(mfcol)` sie spaltenweise füllt.

Der folgende Code erstellt beispielsweise die 2 x 2-Plotting-Matrix des vorigen Beispiels.

```{r}
# Es soll eine 2 x 2 Plotmatrix enstehen:
par(mfrow = c(2, 2))
par(mar = c(0, 1, 6, 1))
# Daten erschaffen
x.data <- rnorm(25)
y.data <- x.data + rnorm(25)
# Plot 1
plot(x = x.data, y = y.data, xaxt = "n", yaxt = "n", xlab = "", ylab = "", main = "pch = 2,\ncol = 'blue'", 
     pch = 2, col = "blue", cex = 1.5, cex.main = 1.2)
# Plot 2
plot(x = x.data, y = y.data, xaxt = "n", yaxt = "n", xlab = "", ylab = "", main = "pch = 16,\ncol = 'orchid2'", 
     pch = 16, col = "orchid2", cex= 1.5, cex.main = 1.2)
# Plot 3
plot(x = x.data, y = y.data, xaxt = "n", yaxt = "n", xlab = "", ylab = "", main = "pch = 21,\ncol = 'black',\nbg = 'orangered2", 
     cex= 1.5, cex.main = 1.2, 
     pch = 21, col = "black", bg = "orangered2")
# Plot 4
plot(x = x.data, y = y.data, xaxt = "n", yaxt = "n", xlab = "", ylab = "", main = "pch = 25,\ncol = 'pink3',\nbg = 'plum3", 
     cex= 1.5, cex.main = 1.2, 
     pch = 25, col = "pink3", bg = "plum3")

``` 
